---
title: 通过quark-design了解webComponent使用封装
tags:

- WebComponent
categories:
- JavaScript笔记
author:
  name: CD
  link: <https://github.com/caidix>
date: 2022-11-01 23:50:44

---
:::tip

前言：Web Components 是一套不同的技术，是实现组件化的一种解决方案, 它允许我们创建一个可重用的定制元素，并且在 web 应用中使用它们。

该文篇幅较长，需要了解的知识点较多，可以分次慢慢阅读。

:::

## [WebComponent](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)

我们可以通过阅读mdn的文档，了解实现webComponent的基本流程。

1. 首先，创建一个类或函数来指定 web 组件的功能
2. js提供了 [window.customElements](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomElementRegistry/define) 及其API来创建自定义元素,这里提及两个后面会用到的API：

- customElements.get(tagName)：返回引用的构造函数的自定义元素的名字，若无该元素，则返回undefined
- customElements.define(tagName, constructor, options)： 创建自定义元素，tagName为元素名，constructor为该元素的构造器，比如可以是一个类，options是一个对象，目前仅有extends属性，用于支持指定继承的已创建的元素。被用于创建自定义元素。

3. 使用[Element.attachShadow()](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/attachShadow) 方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。有人要问，什么是Shadow DOM？你可以将[shadow DOM](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM)视为“DOM中的DOM”。它是自己独立的DOM树，它以 shadow root 节点为起始根节点, 具有自己的元素和样式，与原始DOM完全隔离，就像一个沙盒，这也是我们用它的原因。
4. 在页面任何喜欢的位置使用自定义元素，就像使用常规 HTML 元素那样。

除此之外，我们还需要对以下知识有一定了解：

- [装饰器语法](https://es6.ruanyifeng.com/#docs/decorator)
- [preact](https://github.com/preactjs/preact)

 至此，我们可以开始从quark-design组件库来了解webComponent的强大之处了。

## quark-design

> quark-design 是一款通过webcomponent实现沙箱环境，并借助preact渲染dom,以实现跨技术栈皆可使用的一款UI框架，其除去打包相关内容，最重要的实现则是在[quark-core](https://github.com/hellof2e/quark-design/blob/main/packages/quark-core/src/index.ts)上，下面我们先搭建一个阅读源码的环境。

### 搭建环境

1. 首先，我们需要将框架的源码拉取下来 ：

```bash
git clone git@github.com:hellof2e/quark-design.git
```

2. 安装其官方支持的脚手架工具[Quark CLI]

```bash
npm i -g @quarkd/quark-cli
npx create-quark
cd quark-project
npm install
```

3. 将quark-design中package里的quark-core/src文件夹整个复制到我们创建的项目的src下,文件夹命名为core
4. 将src\main.tsx 下的@quarkd/core 引用 修改成 ./core即可开始本地调试

### 代码流程

> 接下来，我们通过阅读、断点core文件的内容，来逐步解析其实现原理。

#### dblKeyMap.ts

```ts
export default class DblKeyMap<Key1, Key2, Value> {
  private map: Map<Key1, Map<Key2, Value>> = new Map();

  get(key1: Key1, key2: Key2) {
    const subMap = this.map.get(key1);
    if (subMap) {
      return subMap.get(key2);
    }
  }

  set(key1: Key1, key2: Key2, value: Value) {
    let subMap = this.map.get(key1);
    if (!subMap) {
      subMap = new Map();
      this.map.set(key1, subMap);
    }
    subMap?.set(key2, value);
  }

  forEach(cb: (value: Value, key1: Key1, key2: Key2) => void) {
    this.map.forEach((subMap, key1) => {
      subMap.forEach((value, key2) => {
        cb(value, key1, key2);
      });
    });
  }

  delete(key1: Key1) {
    this.map.delete(key1);
  }

  deleteAll() {
    this.map.forEach((_, key1) => {
      this.map.delete(key1);
    });
  }
}
```

DblKeyMap文件实现了一个DblKeyMap文件类，其作用其实是通过Map做了一个二维数组的增删改查遍历，以供后续使用。

#### eventController.ts

> eventController文件的作用是实现了一个EventController类，该类会在指定的元素上注册自定义事件，并将该事件记录到DblKeyMap中，并在指定的时刻可以移除所有监听的事件。其操作主要用于实现发布订阅模式，更具体点实现Vue的 $on, 和 $emit,当$on时bindListener，$emit时dispatchEvent触发该事件。

```ts
import DblKeyMap from './dblKeyMap';

export type EventHandler = (evt: Event) => void;

export class EventController {
  private eventMap: DblKeyMap<Element, string, Set<EventHandler>> =
    new DblKeyMap();

  /** 添加事件监听 */
  bindListener = (
    el: Element | null,
    eventName: string,
    eventHandler: EventHandler
  ) => {
    if (!el || !eventName || !eventHandler) {
      return;
    }

    let list = this.eventMap.get(el, eventName);
    if (!list) {
      list = new Set();
      this.eventMap.set(el, eventName, list);
    }
    if (!list.has(eventHandler)) {
      list.add(eventHandler);
      el.addEventListener(eventName, eventHandler, true);
    }
  };

  /** 移除所有监听事件 */
  removeAllListener = () => {
    this.eventMap.forEach((list, el, eventName) => {
      list.forEach((handler) => {
        el.removeEventListener(eventName, handler);
      });
    });
    this.eventMap.deleteAll();
  };
}

```

#### 通用方法、代理，相关常量

```ts
/** 判空函数 */
const isEmpty = (val: any) => !(val || val === false || val === 0);

export interface PropertyDeclaration {
  /**
   * 是否响应式属性，接收外部的参数变化，会自动加入observedAttributes数组中
   */
  readonly observed?: boolean | string;
  /**
   * 属性类型，会针对类型做不同的特殊处理。
   * Boolean, Number, String
   */
  readonly type?: TypeHint;
  /**
   * 从外部获取属性时的值转换方法
   */
  readonly converter?: converterFunction;
}

/** 默认的属性装饰器 -- 对数字和布尔值做了处理 */
const defaultConverter = (value: any, type?: any): any => {
  let newValue = value;
  switch (type) {
    case Number:
      newValue = isEmpty(value) ? value : Number(value);
      break;
    case Boolean:
      newValue = !([null, "false", false, undefined].indexOf(value) > -1);
      break;
  }
  return newValue;
};

const defaultPropertyDeclaration: PropertyDeclaration = {
  observed: true,
  type: String,
  converter: defaultConverter,
};

const ElementProperties: DblKeyMap<
  typeof QuarkElement,
  string,
  PropertyDeclaration
> = new DblKeyMap();

const Descriptors: DblKeyMap<
  typeof QuarkElement,
  string,
  (defaultValue?: any) => PropertyDescriptor
> = new DblKeyMap();
```

### index关键实现
