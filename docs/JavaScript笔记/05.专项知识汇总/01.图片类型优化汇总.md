---
title: 图片类型、优化、处理知识点汇总
tags: 
  - JavaScript
categories: 
  - JavaScript笔记
author: 
  name: CD
  link: https://github.com/caidix
date: 2022-06-06 23:01:44
permalink: /pages/b715be/
---

## 了解图片格式

> 首先，我们来对常见的图片格式做一个梳理，不同格式的图片也是影响加载的性能的重要因素，在不同的需求条件下选择不同的图片格式也非常有必要。

下面推出大多数的图片格式类型，它们皆在图片上传时可以根据类型进行判断
| 文件格式  | Type类型     | 拓展名     |
| ---------------------------------------- | -------------------------------------------------- | -------------------------------------------- |
| APNG (Animated Portable Network Graphics 动态便携式网络图像) | image/apng | .apng |
| AVIF(AV1 Image File Format AV1 图像文件格式) | image/avif | .avif |
| BMP(Bitmap file 位图文件) | image/bmp | .bmp |
| Graphics Interchange Format 图像互换格式 | image/gif | .gif |
| Microsoft Icon 微软图标 | image/x-icon | .ico, .cur |
| Joint Photographic Expert Group image 联合影像专家小组图像 | image/jpeg | .jpg, .jpeg, .jfif, .pjpeg, .pjp |
|  Portable Network Graphics 便携式网络图像 | image/png | .png |
|  Scalable Vector Graphics 可缩放矢量图形 | image/svg+xml | .svg |
|  Tagged Image File Format 标签图像文件格式 | image/tiff | .tif, .tiff |
|  Web Picture format 万维网图像格式 | image/webp | .webp |

## 了解图片压缩

### 计算机表示图片的方式

首先，我们先谈谈计算机是如何表示图片的。在标准计算机中使用的色彩模型为RGB模型，也就是我们css中常写到的模型rgb(Red, Green, Blue)。图片是由多个像素点组成，图像中的每个像素都存储了三个值，范围从0~255。其中某个值越大，其对应的颜色就有着越大的权重（假设每个色彩分量都用8个比特(即1字节)来表示，那么一个像素点就占了3个字节（Red+Green+Blue)）。计算机需要先将我们的图片通过复杂的解码操作，将其从一个（例如.jpg)图片文件还原成计算机原有的RGB格式以便计算机渲染。那么流程就可以看作以下步骤:

**RGB模型组合** --> **Encoder组件编码** --> **生成.jpg图片** --> **Decoder组件解码** --> **还原为RGB模型组合**

在这个解码的过程中，我们其实并不需要还原得跟未压缩的原始图片一模一样，在有限的情况下并不会对人的视觉产生影响，但却减小了文件的体积。jpeg的体积相较于jpg更小的原因就是其分别定义了编码和解码的流程，在作业流程的压缩部分有意的丢失部分信息，这种对图片的处理方式，我们通常称呼其为：**有损压缩**。

### 有损压缩

> 有损数据压缩（英语：lossy compression）是一种数据压缩方法，经过此方法压缩、解压的数据会与原始数据不同但是非常接近。有损数据压缩又称破坏性资料压缩、不可逆压缩。有损数据压缩借由将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比。根据各种格式设计的不同，有损数据压缩都会有代间损失 —— 每次压缩与解压文件都会带来渐进的质量下降。

有损压缩的一种方式即是利用了人类对颜色的判断并没有那么敏感的缺陷：假设一张图片由8\*8个像素点组成，通过复杂的计算，损失颜色空间，细化亮度空间的维度，将其合并为4\*4个像素点的图片, 并有策略的去除图片中不太重要、较少见的高频信号来达到更高的压缩率。在真实的场景中，一张图片通常拥有上万个像素点，人通过肉眼基本分辨不出抽样后的图片相较之前有何差异。推荐观看视频来了解有损压缩更细枝末节的内容：[JPEG不可思议的压缩率——归功于信号处理理论](https://www.bilibili.com/video/BV1iv4y1N7sq?spm_id_from=333.337.search-card.all.click)

通常有损压缩大多出现在jpeg类型，以满足更小的内存占用和更快的解码速度。

### 无损压缩

> 无损数据压缩（Lossless Compression），是指资料经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样。相比之下，有损数据压缩只允许一个近似原始资料进行重建，以换取更好的压缩率。
无损数据压缩在许多应用程序中使用。例如，ZIP和gzip。无损压缩的方法可以通过一些编码手段，用结构化的数据来减少对重复信息的磁盘占用，针对图片来说减少了图片在磁盘上的空间占用。但是并不能减少图像的内存占用量，这是因为，当从磁盘或网络请求上获取图像时，浏览器又会对图片进行解码，把丢失的像素用适当的颜色信息填充进来。

举个例子，当我们在看片的时候，我们按顺序走，先看了悠亚的，再看了某萌的，当我们再次看到悠亚的时，我们可以认为第一部和第三部都是同一个人出演的，这时候我们可以用第一部来代替第三部，于是我们通过一个替代的规则：（距离，长度）为第三部片子打上标记，假设第一部是1，第二部是2，从第三部到第一部要向前一步，距离就为1，第一部的标记长度为1，那么第三部的标记则为 **(1,1)**  ，即向前一步，向前读取一位，但原本只需要标记为3的第三部戏被标记成了 **(1,1)** ,从某种程度上来说，有可能会出现越压越大的情况。

对于无损压缩而言，有一个概念“熵”，可以理解为一个东西的复杂程度。以扑克牌为例，总共54张牌，而除去相同的点数，只有15种牌，那它的复杂程度，也就是“熵”，就是 15，压缩是有一个定律就是压缩的大小不可能小于熵的大小，所以如果一个文件有1GB，但这 个文件的熵为99MB，那么它完全有可能压缩到100MB。

## 图片优化

> 图片的优化分为加载和显示两个阶段

### 加载阶段

#### 减小体积

减小体积的最好办法就是上文说到的有损压缩，减少请求耗时，让浏览器更快拿到内容进行绘制。

#### 减小内存占用

内存占用和图片体积不等同，两张不同体积的图片可能有着相同的内存占用，因此优化内存占用可以让浏览器解码图片和光栅化的时间减少，因为不需要计算绘制那么多的图片信息。光栅化时间的减少直接影响了页面的渲染速度，以及页面的卡顿。

### 显示阶段

#### 添加占位

添加图片加载时的占位和图片错误时的占位图，能够提升用户的体验，减少等待期间的用户流失。

#### 懒加载

减少同屏下过多的请求导致页面白屏等问题，减少不必要的资源请求，减少内存占用。

#### 格式回退

对于不同浏览器的对格式的支持不同，选择不同格式的图片进行展示，达到优雅降级的目的。例如不支持webp时自动降级成png（这里需要ui提供几种格式的图片）
例如这里我们可以使用picture标签帮我们做自动降级的处理，并且最终的加载事件仍会落在img标签上，事件的监听仍会生效。

```html
<picture>
  <source srcSet={avif} type="image/avif" />
  <source srcSet={webp} type="image/webp" />
  <img src={image} onError={() => onError?.()} {...remain} />
</picture>
```

## 关于\<Img>元素

1. \<img> 是一个可替换元素。它的 display 属性的默认值是 inline，但是它的默认分辨率是由被嵌入的图片的原始宽高来确定的，使得它就像 inline-block 一样，可以为其设置block生效的属性。
2. \<img> 元素并没有基线(baseline)。意味着当其行内上下文设置的基线位置为baseline时（ vertical-align: baseline），它在同一行内遇上其他的行内（块）元素，图像的底部将会与容器的文字基线对齐
3. 额外的，除了src属性，\<img> 还有srcset 属性，在高分辨率设备上，它将被优先加载，取代 src 属性中的图像。
