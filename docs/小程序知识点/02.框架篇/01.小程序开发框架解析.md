---
title: 小程序开发框架解析
date: 2023-02-13 20:00:00
tags:
  - 小程序
categories:
  - 小程序笔记
author:
  name: CD
  link: https://github.com/caidix
---

> 目前市面上的小程序种类繁多，目前以微信小程序的支持最为完善，其余的就是支付宝、淘宝、抖音、百度等小程序。它们的底层方案都是一致的，只不过在支持程度上有所不同。

**以⽀付宝⼩程序为例：**

1. ⼩程序分别运⾏在 worker(JSEngine) 以及 render 渲染层中， render 可以有多个， worker 只有⼀个，⽅便 app 数据在⻚⾯间的共享和交互；（渲染层 & 逻辑层）
2. worker 运⾏⼩程序的逻辑处理代码，包括事件处理，api 调⽤以及框架的⽣命周期管理；（逻辑层功能）
3. render 运⾏⼩程序的渲染代码，主要包括模版／样式和框架的跨终端的 js 组件或 native 组件，获取逻辑层的数据进⾏渲染；（渲染层功能）
4. worker 和所有的 render 都建⽴连接，将需要渲染的数据传递给对应的 render 进⾏渲染，worker 也会将 api 调⽤转给 native SDK 处理；（Hybrid 通信）
5. render 则将组件的触发事件送到对应的 worker 处理，同时接受 worker 的 setData 调⽤ React 重新渲染。 render 可以看作⼀个⽆状态的渲染终端，状态统统保留在 app 级别的 worker ⾥⾯；（渲染层&逻辑层交互）

[时间轴](/vuepress-interview-github/assets/miniprogram/miniprogram-6.png)

## 小程序跨端框架

> 由于原生小程序的语法与当今主流的前端开发框架的差异及当今对代码在多端运行的需求颇多，衍生出了许多兼容多端的前端跨端开发框架，下面分析已 react 语法为主的跨端框架；

### 编译时

> ⽤户编写的业务代码解析成 AST 树，然后通过语法分析强⾏将⽤户写的类 React 代码转换为可运⾏的⼩程序代码,代表：京东的 Taro1/2、去哪⼉的 Nanachi，淘宝的 Rax。

[编译时](/vuepress-interview-github/assets/miniprogram/miniprogram-7.png)

编译时链路主要分为五个模块：

1. CLI：整个链路的⼊⼝，⽤户编写的所有业务代码都经由 CLI 读取、处理和输出；
2. loader：webpack loader，⽤于处理各种类型的⽂件，包括 app、page、component、script 以及
   静态资源等；
3. compiler：⽤于进⾏ AST 转换并⽣成对应的⼩程序代码；
4. runtime：为⽣成的 js 代码提供了运⾏时的**垫⽚**⽀持；
5. universal：多端统⼀的 universal 组件以及 API 的基础服务⽀持；

#### CLI

> 从命令⾏读取各种必要参数，然后传⼊ webpack 执⾏。利⽤ webpack 的依赖分析能⼒，遍历到所有有效代码并交由对应的 loader 进⾏处理。 CLI 对外提供 watch 和 build 两个指令: 1. watch：监听代码变动并实时编译,2:build：剔除部分调试⽤的代码（如 source map）并压缩代码，完成编译打包；

下面是 RAX 框架 watch 和 build 的部分代码

**watch**

```js
/**
 * watch and copy constant dir file change
 * @param {array} dirs
 * @param {string} distDirectory
 */
function watch(options = {}) {
  const {
    afterCompiled,
    type = DEFAULT_TYPE,
    entry = DEFAULT_ENTRY,
    platform = DEFAULT_PLATFORM,
    workDirectory = cwd,
    distDirectory = join(cwd, DEFAULT_DIST),
    skipClearStdout = false,
    constantDir = DEFAULT_CONSTANT_DIR_ARR,
    disableCopyNpm = false,
    turnOffSourceMap = false,
    turnOffCheckUpdate = false,
  } = options;
  watchConstantDir(constantDir, distDirectory);
  const needUpdate = checkNeedUpdate(turnOffCheckUpdate);
  let config = getWebpackConfig({
    mode: "watch",
    entryPath: entry,
    type,
    workDirectory,
    platform,
    distDirectory,
    constantDir,
    disableCopyNpm,
    turnOffSourceMap,
  });
  if (options.webpackConfig) {
    config = mergeWebpack(config, options.webpackConfig);
  }
  spinner.shouldClear = !skipClearStdout;
  const compiler = webpack(config);
  const watchOpts = {
    aggregateTimeout: 600,
  };
  compiler.outputFileSystem = new MemFs();
  compiler.watch(watchOpts, (err, stats) => {
    handleCompiled(err, stats, { skipClearStdout });
    afterCompiled && afterCompiled(err, stats);
    if (needUpdate) {
      console.log(
        chalk.black.bgYellow.bold(
          "Update for miniapp relatedpackages available, please reinstall dependencies."
        )
      );
    }
    console.log("Watching for changes...");
  });
}
/**
 * watch and copy constant dir file change
 * @param {array} dirs
 * @param {string} distDirectory
 */
function watchConstantDir(dirs, distDirectory) {
  const watcher = chokidar.watch(dirs);
  watcher.on("all", (event, path) => {
    copyConstantDir(path, distDirectory);
  });
}
/**
 * copy constant path to dist
 * @param {string} path
 * @param {string} distDirectory
 */
function copyConstantDir(path, distDirectory) {
  if (!path) {
    return;
  }
  if (!existsSync(path)) {
    mkdirSync(path);
  }
  copySync(path, join(distDirectory, getCurrentDirectoryPath(path, "src")), {
    filter: (filename) => !/\.ts$/.test(filename),
  });
}
function handleCompiled(err, stats, { skipClearStdout }) {
  if (err) {
    console.error(err.stack || err);
    if (err.details) {
      console.error(err.details);
    }
    return;
  }
  if (stats.hasErrors()) {
    const errors = stats.compilation.errors;
    if (!skipClearStdout) consoleClear(true);
    spinner.fail("Failed to compile.\n");
    for (let e of errors) {
      console.log(
        chalk.red(`   ${errors.indexOf(e) + 1}.
  ${e.error.message} \n`)
      );
      if (process.env.DEBUG === "true") {
        console.log(e.error.stack);
      }
    }
    console.log(
      chalk.yellow("Set environment `DEBUG=true` to see detail error stacks.")
    );
  }
}
```

其实 watch 做的事情就是将 webpack 配置传入后启动了一个本地服务器来运行代码,build 同理，做一些配置化的工作

**build**

```js
/**
 * Start jsx2mp build.
 * @param options
 */
function build(options = {}) {
  const {
    afterCompiled,
    type = DEFAULT_TYPE,
    entry = DEFAULT_ENTRY,
    platform = DEFAULT_PLATFORM,
    workDirectory = cwd,
    distDirectory = join(cwd, DEFAULT_DIST),
    skipClearStdout = false,
    constantDir = DEFAULT_CONSTANT_DIR_ARR,
    disableCopyNpm = false,
    turnOffCheckUpdate = false,
  } = options;
  // Clean the dist dir before generating
  if (existsSync(distDirectory)) {
    del.sync(distDirectory + "/**");
  }
  constantDir.forEach((dir) => copyConstantDir(dir, distDirectory));
  const needUpdate = checkNeedUpdate(turnOffCheckUpdate);
  let config = getWebpackConfig({
    mode: "build",
    entryPath: entry,
    platform,
    type,
    workDirectory,
    distDirectory,
    constantDir,
    disableCopyNpm,
  });
  if (options.webpackConfig) {
    config = mergeWebpack(config, options.webpackConfig);
  }
  spinner.shouldClear = !skipClearStdout;
  const compiler = webpack(config);
  compiler.outputFileSystem = new MemFs();
  compiler.run((err, stats) => {
    handleCompiled(err, stats, { skipClearStdout });
    afterCompiled && afterCompiled(err, stats);
    if (needUpdate) {
      console.log(
        chalk.black.bgYellow.bold(
          "Update for miniapp related packages available, please reinstall dependencies."
        )
      );
    }
  });
}

// 依赖 webpack 对项⽬进⾏依赖分析，然后调⽤ loader对对应类型的⽂件进⾏处理
const AppLoader = require.resolve("jsx2mp-loader/src/app-loader");
const PageLoader = require.resolve("jsx2mp-loader/src/page-loader");
const ComponentLoader = require.resolve("jsx2mp-loader/src/componentloader");
const ScriptLoader = require.resolve("jsx2mp-loader/src/script-loader");
const FileLoader = require.resolve("jsx2mp-loader/src/file-loader");
function getEntry(type, cwd, entryFilePath, options) {
  const entryPath = dirname(entryFilePath);
  const entry = {};
  const {
    platform = "ali",
    constantDir,
    mode,
    disableCopyNpm,
    turnOffSourceMap,
  } = options;
  const loaderParams = {
    platform: platformConfig[platform],
    entryPath: entryFilePath,
    constantDir,
    mode,
    disableCopyNpm,
    turnOffSourceMap,
  };
  if (type === "project") {
    // ....
    entry.app =
      AppLoader +
      "?" +
      JSON.stringify({
        entryPath,
        platform: platformConfig[platform],
        mode,
        disableCopyNpm,
        turnOffSourceMap,
      }) +
      "!./" +
      entryFilePath;
    if (Array.isArray(appConfig.routes)) {
      appConfig.routes
        .filter(({ targets }) => {
          return !Array.isArray(targets) || targets.indexOf("miniapp") > -1;
        })
        .forEach(({ source, component, window = {} }) => {
          component = source || component;
          entry["page@" + component] =
            PageLoader +
            "?" +
            JSON.stringify(
              Object.assign({ pageConfig: window }, loaderParams)
            ) +
            "!" +
            getDepPath(component, entryPath);
        });
    } else if (Array.isArray(appConfig.pages)) {
      // Compatible with pages.
      appConfig.pages.forEach((pagePath) => {
        entry["page@" + pagePath] =
          PageLoader +
          "?" +
          JSON.stringify(loaderParams) +
          "!" +
          getDepPath(pagePath, entryPath);
      });
    }
  }
  if (type === "component") {
    entry.component =
      ComponentLoader +
      "?" +
      JSON.stringify(loaderParams) +
      "!" +
      entryFilePath;
  }
  return entry;
}
module.exports = (options = {}) => {
  const config = {
    mode: "production", // Will be fast
    entry: getEntry(type, workDirectory, relativeEntryFilePath, options),
    output: {
      path: distDirectory,
    },
    target: "node",
    context: workDirectory,
    module: {
      rules: [
        {
          test: /\.t|jsx?$/,
          use: [
            {
              loader: ScriptLoader,
              options: {
                mode: options.mode,
                entryPath: relativeEntryFilePath,
                platform: platformConfig[platform],
                constantDir,
                disableCopyNpm,
                turnOffSourceMap,
              },
            },
            {
              loader: BabelLoader,
              options: getBabelConfig(),
            },
          ],
        },
        {
          test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/, /\.webp$/],
          loader: FileLoader,
          options: {
            entryPath: relativeEntryFilePath,
          },
        },
        {
          test: /\.json$/,
          use: [
            {
              loader: ScriptLoader,
              options: {
                mode: options.mode,
                entryPath: relativeEntryFilePath,
                platform: platformConfig[platform],
                constantDir,
                disableCopyNpm,
                turnOffSourceMap,
              },
            },
          ],
        },
      ],
    },
    resolve: {
      extensions: getPlatformExtensions(platform, [
        ".js",
        ".jsx",
        ".ts",
        ".tsx",
        ".json",
      ]),
      mainFields: ["main", "module"],
    },
  };
  return config;
};
```

我们可以看到代码内对 appConfig.routes、appConfig.pages 做了一系列的操作，这主要是 RAX 通过其配置文件 app.json,获取到所有需要页面的路由，再对所有的页面作为入口，所有依赖⽂件将依次被遍历并交由对应 loader 进⾏处理。loader 处理完毕后最终的编译代码将⽣成到⽬的⽬录。

```js
{
  "routes": [
   {
      "path": "/",
      "source": "pages/Home/index"
   }
 ],
 "window": {
    "defaultTitle": "Rax App 1.0"
 }
}
```

#### Loader

在 RAX 的 build 指令中，可以看到代码通过了几个 loader 的运作，最终打包成了小程序的代码

1. AppLoader

首先，是 AppLoader，它用来处理 rax 源码中的 app.js 文件，并将 app.json 中 的 `window` 属性并作⽀付宝/微信两端的配置抹平

```js
module.exports = async function appLoader(content) {
  const query = parse(this.request);
  // Only handle app role file
  if (query.role !== "app") {
    return content;
  }
  if (!existsSync(outputPath)) mkdirpSync(outputPath);
  const compilerOptions = Object.assign({}, compiler.baseOptions, {
    // ...options,
  });
  const rawContentAfterDCE = eliminateDeadCode(rawContent);
  let transformed;
  try {
    transformed = compiler(rawContentAfterDCE, compilerOptions);
  } catch (e) {
    console.log(
      chalk.red(`\n[${platform.name}] Error occured when
handling App ${this.resourcePath}`)
    );
    if (process.env.DEBUG === "true") {
      throw new Error(e);
    } else {
      const errMsg = e.node
        ? `${e.message}\nat ${this.resourcePath}`
        : `Unknown compile error! please check your code at ${this.resourcePath}`;
      throw new Error(errMsg);
    }
  }
  const { style, assets } = await processCSS(transformed.cssFiles, sourcePath);
  transformed.style = style;
  transformed.assets = assets;
  const outputContent = {
    code: transformed.code,
    map: transformed.map,
    css: transformed.style ? defaultStyle + transformed.style : defaultStyle,
  };
  const outputOption = {
    outputPath: {
      code: join(outputPath, platform.type === QUICKAPP ? "app.ux" : "app.js"),
      css: join(outputPath, "app" + platform.extension.css),
    },
    mode,
    isTypescriptFile: isTypescriptFile(this.resourcePath),
    type: "app",
    platform,
    rootDir,
  };
  output(outputContent, rawContent, outputOption);
  return [
    `/* Generated by JSX2MP AppLoader, sourceFile: ${this.resourcePath}.
*/`,
    generateDependencies(transformed.imported),
  ].join("\n");
};
```
