# 网络

## 1. 计算机网络的体系结构
1. 4层协议：应用层->运输层->网际层->网络接口层
2. 5层协议：应用层（FTP、SMTP）-> 运输层（TCP、UDP）-> 网络层（IP）-> 数据链路层 -> 物理层

- 应用层：应用层通过应用进程间的交互来完成特定的网络应用。对于不同的网络应用需要有不同的应用层协议。如域名系统DNS，支持万维网应用的http协议，支持电子邮件的SMTP协议，应用层之间的交互数据单元为报文。
- 运输层：负责向两台主机中进程之间的通信提供通用的数据传输协服务，主要使用以下两种协议；传输控制协议TCP：面向连接的、可靠的数据传输服务，单位为报文段。用户数据报协议UDP：无连接的、尽最大努力的数据传输服务，不保证可靠性，单位为用户数据报。传输层的作用是指出具体该把数据包发给哪个应用，通过端口来分辨应用。同一个端口不会同时出现，传输层通过辨认端口号来确认应用。但是只靠端口号识别通信是不够的。需要采取五个信息来识别一个通信，分别是源 IP 地址，目标 IP 地址，协议号，源端口号，目标端口号。两个包中只要任何一个信息不同就不是同一个通信。
- 网络层：为分组交换网上的不同主机提供通信服务。在发送数据时。网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在tcp/ip体系中，使用ip协议，因此分组也叫做IP数据报，简称数据报。由于互联网是由大量异构网络通过路由器相互连接起来的，因此互联网使用的网络层协议是无连接的网际协议IP和多种路由选择协议。
- 数据链路层：将网络层传下来的ip数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）控制信息可以在链路层阶段发现收到的帧是否有差错，如果有则在该阶段丢弃这个出错的帧，避免继续在网络中传送下去白白浪费网络资源。
- 物理层：利用物理媒体传输，单位为比特。

## 2. TCP/UDP/IP协议
> 协议是控制两个对等实体（或多个实体）进行通信的规则的集合。通信的真正端点并不是主机而是主机中的进程。两个计算机进程想要相互通信，不仅需要知道对方的IP地址，而且要知道对方的端口号，从而找到相应计算机的应用进程，熟知的端口号有http80，https443，dns53

### UDP：用户数据报协议
1. UDP是无连接的，发送数据之前、结束后不需要建立、释放连接，较少了开销和发送数据之前的时延。
2. UDP是尽最大努力交付，即不保证可靠交付。因此主机不需要维持复杂的连接状态表。
3. UDP是面向报文的。应用层交下来的报文，UDP既不合并也不拆分，而是保留这些报文的边界。UDP为报文增加首部后就向下交付IP层。也就是说，UDP一次交付一个完整的报文。所以若报文过长或者过短都会降低IP层的效率。
4. UDP没有拥塞控制，网络上出现的拥塞不会使源主机发送效率降低。
5. UDP支持一对一，一对多，多对一，多对多的交互通信。
6. UDP首部开销小，只有8个字节，而TCP有20个字节。
7. UDP的首部格式： 由四个字段组成，每个字段的长度都是两个字节。
- 源端口：源端口号，需要对方回信时选用，不需要时可全0
- 目的端口：目的端口号，在终点交付报文时必须使用。
- 长度：UDP用户数据报的长度，最短为8字节（仅有头部）
- 检验和：检验UDP用户数据报在传输过程中是否有错。有错就丢弃

### TCP 传输控制协议
1. TCP是面向连接的运输层协议。在使用TCP协议之前，必须先建立连接（3次握手），结束之后必须释放已经建立的TCP链接（4次分手）。
2. 每一条TCP链接只能由两个端点，每一条TCP链接只能是点对点的。
3. TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。
4. TCP提供全双工通信。允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。
5. 面向字节流。TCP不保证接收方应用程序所受到的数据块和发送方的应用程序所发出的数据块具有对应大小的关系，但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。

### IP
1. IP 地址
每块网卡需配置至少一个 IP 地址
IP 地址由32位正整数组成，为二进制，但是为了人类更好的阅读，将他每8位分为一组，共4组
IP 地址由网络和主机两标识组成
网络标识在数据链路的每个段配置不同的值，必须保证相互连接的端的地址不重复
主机标识不允许在同一网段内重复

IP 地址分为四个级别，分别为 A, B, C, D
A类地址是首位为 0 开头，前八位是网络标识， 0.0.0.0 ~ 127.0.0.0属于 A 类
B 类地址是前两位由 10 组成，前16位是网络标识，128.0.0.0 ~ 191.255.0.0 属于 B 类
C 类地址前三位是 110， 前24位是网络标识，192.0.0.0 ~ 239.255.255.0 属于 B 类
D 类前四位是 1110，32位全是网络标识，224.0.0.0 ~ 239.255.255.255属于 D 类

但是以上的分类已经不用，改为使用子网掩码定位网络标识长度。
子网标识同一个网关，255.255.255.0和255.255.255.1是同一个子网
子网掩码也是32位组成
掩码中有几个1就代码几位网络标识，其他为主机标识
假如掩码前24位为1，就代表前24位都为网络标识，用 IP 地址标识就是255.255.255.0，后面的0代表主机标识，理论上有256台主机可连接
2. 路由控制
仅有 IP 地址还不足以将数据包发送到对端，还需指明路由器或主机。保存这种信息的就是路由控制表。
路由控制表中记录着地址与下一步要发送至路由器的地址。在发送 IP 包时，先确定 IP 包首部目标地址，然后在表中找到与该地址具有相同网络地址的记录，根据记录将 IP 包转发给相应的下一个路由器。

## 3.[DNS网域名称系统](https://juejin.im/post/59c6201df265da064428b835)
> 它实质上是一个 域名 和 IP 相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。
DNS有以下特点：
- 分布式的
- 协议支持TCP 和 UDP, 常用端口是53
- 每一级域名的长度限制是63
- 域名总长度限制是253

## 4.HTTP常见状态码
### 2开头 （请求成功）表示成功处理了请求的状态代码

- 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 201 （已创建） 请求成功并且服务器创建了新的资源。
- 202 （已接受） 服务器已接受请求，但尚未处理。
- 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
- 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
- 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
- 206 （部分内容） 服务器成功处理了部分 GET 请求。

### 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

- 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent)选择一项操作，或提供操作列表供请求者选择。
- 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD请求的响应）时，会自动将请求者转到新位置。
- 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
- 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
- 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
- 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

### 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。

- 400 （错误请求） 服务器不理解请求的语法。
- 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 （禁止） 服务器拒绝请求。
- 404 （未找到） 服务器找不到请求的网页。
- 405 （方法禁用） 禁用请求中指定的方法。
- 406 （不接受） 无法使用请求的内容特性响应请求的网页。
- 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
- 408 （请求超时） 服务器等候请求时发生超时。
- 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
- 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
- 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
- 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
- 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
- 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
- 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
- 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
- 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

### 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

- 500 （服务器内部错误） 服务器遇到错误，无法完成请求。
- 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
- 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
- 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
- 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

## 5. GET和POST的区别
 
## 6. [HTTP1.0~3的历程](https://juejin.im/post/5dbe8eba5188254fe019dabb)

## 7. 从输入域名到渲染出页面都经历了什么
### 浏览器的多进程架构
在chrome中，一个页面 浏览器就会为其分配一个进程，每个页面的进程相对独立，单独页面的崩溃并不会影响到其他页面的正常运行。
1. 浏览器进程:负责浏览器的用户交互、子进程管理和文件存储功能。比如tab的前进后退、处理一些不可见的底层操作如网络请求等。
2. 网络进程: 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
3. 渲染进程: 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。

### 网页加载的过程
- 首先，用户从浏览器进程里输入请求信息；
- 然后，网络进程发起 URL 请求；
- 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了；
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；
- 渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

### 用户输入
当用户在地址栏中输入查询的关键字时， 浏览器回去根据正则规则去判断它是一个网站链接还是一个搜索内容。同时会根据输入内容是否符合url协议去将输入的链接整合成一个完整的url。

### url请求过程
- 浏览器进程会通过进程间通信（IPC）把URL请求发送给网络进程，网络进程接收到请求后，会先去查找本地缓存，如果有本地缓存资源，则直接返回资源给浏览器进程。如果没有找到，那么直接
进入网络请求流程。第一步是进行DNS域名解析，将域名的所属的IP解析出来,如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS解析。如果是HTTPS协议，还需要建立TLS链接。
- 建立TCP连接，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。当通过IP地址和服务器建立了TCP连接之后，浏览器端会构建请求行、请求头和请求体，并把域名相对应的cookie等数据附加在请求头中，然后向服务器发送构建的请求信息。
- 服务器接收到请求信息后，根据请求信息生成响应数据（包括响应头、响应行、响应体等信息），并发给网络进程。网络进程接受到了响应行和 响应头后，开始解析响应头的内容。
1. 重定向：在接收到服务器返回的响应头后，网络进程开始解析响应头。 如果发现返回的状态码是301或是302，说明服务器需要浏览器重定向至其他的URL，这时候网络进程会去响应头中拿到重定向的数据Location,然后重新发起HTTP或者HTTPS请求，然后重新走url的请求过程。直到响应行的状态码是200的时候，则表示浏览器可以继续处理该请求。
2. 响应数据类型处理：当处理了跳转信息之后，浏览器会根据响应头中的Content-Type来决定如何显示响应体的内容。若返回的是字节流类型的，浏览器一般会按照下载类型来处理该需求，
该请求会被提交给下载管理器，同时结束这次请求。如果是HTML，那么浏览器则会继续进行导航流程。准备渲染进程。
3. 准备渲染进程：默认情况下，chrome会为每一个页面分配一个渲染进程，当然也有例外，如果多个页面都是相同域名下的子域名，或是不同的端口，都认为他们是同一站点。Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

4. 提交文档：这里的“文档”是指 URL 请求的响应体数据。
“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

5. 渲染阶段：文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有CSS的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。
如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。
CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
在生成 Render 树的过程中，浏览器就开始调用GPU 绘制，合成图层，将内容显示在屏幕上了。
一个完整的渲染流程大致可总结为如下：

渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
创建布局树，并计算元素的布局信息。
对布局树进行分层，并生成分层树。
为每个图层生成绘制列表，并将其提交到合成线程。
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
合成线程发送绘制图块命令DrawQuad给浏览器进程。
浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

相关概念
- 构建DOM树：因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
- 构建CSSOM树： 首先，将css转换为浏览器能够理解的结构（styleSheets），并将属性里所有的值转换为渲染引擎更容易理解的、标准化的计算值（1em = 32px),从而计算出dom树中每个节点的具体样式。生成一个完整的布局树。
- 重排（更新了元素的几何属性）如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。
- 重绘（更新元素的绘制属性）如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。


## 8. 跨域攻击
1. CSRF跨站请求伪造。通过钓鱼网站，嵌入真实网站的请求。比如用户在进入钓鱼网站之前登陆了真实的银行等站点并把COOKIE保存了起来，这时候钓鱼网站把请求发出去的时候就会把cookie也一并带上，另一端以为是正常的请求，就执行。


## 9. 跨域
1. jsonp
```javascript
function sendJsonp(params) {
  const {url, callback, timeout, data} = params;
  let timer, str = '';
  sendJsonp.id = sendJsonp.id || 1;
  let id  = sendJsonp.id;
  function cleanup() {
    if (script.parentNode) {
      script.parentNode.removeChild(script);
      window[name] = null;
    }
    if (timer) {
      clearTimeout(timer);
    }
  }
  if (timeout) {
    timer = setTimeout(()=> {
      callback('超时');
      cleanup();
    },timeout);
  }
  let name = `cd_${id}`;
  window[name] = res => {
    if (window[name]){
      cleanup();
    }
    callback('成功',res);
  }
  for(const key in data) {
    const value = data[key]!==undefind? data[key]: '';
    str+=`${key}=${encodeURIComponent(value)}&`;
  }
  url = url + '?' + str + `callback=${name}`;
  const script = document.createElement('script');
  script.type='text/javascript';
  script.src = url;
  document.head.appendChild(script);
  // id自增
  sendJsonp.id++;
}

sendJsonp({
  url: 'http://abc.com/api/get',
  data: {
    name:'cd',
    password: 'cd真TM帅'
  },
  callback: (err,data) => {
    console.log('callback;', err, data)
  },
  timeout: 10000 // 单位是毫秒
})
```

2. cors跨域资源共享（Cross-origin resource sharing）在发生跨域请求之前，发送了一个OPTIONS请求去询问服务器是否允许接下来的跨域请求
如果是简单请求，则不会触发预检，直接发出正常请求。
OPTIONS里有几个字段： 
- Origin 发起请求原来的域
- Access-Control-Request-Method: 将要发起跨域的请求方式
- Access-Control-Request-Headers: 将要发起的跨域请求中包含的请求头字段

服务器在响应字段中来表明是否允许这个跨域请求，浏览器收到后检查如果不符合要求，就拒绝后面的请求。
- Access-Control-Allow-Origin:允许哪些域来访问（*为所有域名下的请求）
- Access-Control-Allow-Methods:允许哪些请求方式
- Access-Control-Allow-Headers: 允许那些请求头字段
- Access-Control-Allow-Credentials:是否允许携带cookie
- Access-Control-Max-Age： 服务器返回两者可通讯的有效期，在有效期内不需要再调用OPTIONS请求询问。
对此，chrome还做了优化：
如果是一个简单请求，那就直接发起请求，只需在请求中加入Origin字段表明自己来源，在响应中检查Access-Control-Allow-Origin，如果不符合要求就报错，不需要再单独询问了。
简单请求就是请求方式属于HEAD、GET、POST三者之一，请求头只有下面这些，不符合要求的就是非简单请求，就得询问了”
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：(application/x-www-form-urlencoded、multipart/form-data、text/plain)

cors简单跨域请求代码示例
```javascript
var xhr = XMLHttpRequest();
xhr.withCredentials = true;
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send('user=adsad');
xhr.onreadystatechenge=function() {
  if(xhr.readyState==4 && xhr.status ===200) {
    alert(xhr.responseText)
  }
}
```
cors跨域的优点
- 支持所有类型的http请求，功能完善
- 通过onerror事件监听进行调用错误处理
- 通过Access-Control-Allow-Origin进行资源访问授权

cors跨域缺点
- 主流（ie10）浏览器都支持cors，但ie8和ie9需要使用XDomainRequest对象进行兼容。i7以下不兼容

3. 服务器代理
顾名思义在发送跨域请求时，后端进行代理中转请求到服务器端，然后获取数据返回给前端，适用以下场景：
- 针对IE7及以下浏览器摒弃flash插件的情况，配置代理接口与前端页面同源，并中转目标服务器接口，则ajax请求不存在跨域
- 外网前端页面无法访问内网接口，配置代理接口允许前端页面访问，并中转内网接口，则外网前端页面可以跨域访问内网接口

缺点就是后端需要一定的改造工作量

### 前端跨域通信解决方案
1. document.domain + iframe
适用于主域相同，子域不同的前端通信跨域场景，比如a.cd.top和b.cd.top 两者有着相同的主域cd.top. a嵌套b，再通过js设置document.domain为主域cd.top,则两个页面满足了同源策略，从而实现了跨域通信。
```html
A页面
<iframe id="iframe" src="b.cd.top"></iframe>
<script>
  document.domain="cd.top";
  var windowB = document.getElementById('iframe').contentWindow;
  alert('B页面变量' + windowB.user)
</script>

B页面
<script>
  document.domain="cd.top"
  var user = 'CD'
</script>
``` 

优点：实现逻辑简单，不需额外的中转页面
缺点：仅适用于主域相同，子域不同的前端通信跨域场景。

2. location.hash + iframe
3. window.name+iframe


## 10. 浏览器的缓存机制
<img src="https://upload-images.jianshu.io/upload_images/3174701-8e74b69ad9376710?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp"/>

[深入理解缓存机制](https://www.jianshu.com/p/54cc04190252)
通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。
### 强缓存
> 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

- Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。

- Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：

- public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser <-- proxy1 <-- proxy2 <-- Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。

- private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。

- no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。

- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

- max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效

- s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。

- max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。

- min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受

### 协商缓存
> 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：1.协商缓存生效，返回304和Not Modified;2.协商缓存失效，返回200和请求结果
协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

### 缓存机制
强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。


## 11. 说一说浏览器的本地存储
### cookie
cookie的诞生本身是为了弥补http在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种情况下，就有了cookie
Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。当在同一个域名下发送请求时，都会携带相同的cookie，服务器可以根据拿到的cookie进行解析，从而拿到客户端的状态。可以说cookie的作用是用来做状态存储的。cookie设置时可以为其设置过期时间。
缺点：
- 容量小，只有4kb，只能用来存储少量的信息。
- 性能可能会有浪费。cookie对应域名存储，不管域名下面的某一个地址是否需要这些cookie，都会携带上完整的cookie，这样随着请求数量的增多，其实会造成巨大的性能浪费的，因为携带和许多不必要的内容。
- 安全问题。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly（是否可通过客户端脚本访问）为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

cookie分为两种类型：一种是session cookies 一种是Persistent cookies，如果cookie不包含到期时间，则视为绘画cookie，存放于内存中，永远不会写入磁盘，当浏览器关闭后，会清除该会话cookie。如果cookie有有效期，则视为持久性cookie存入磁盘，在指定的日期，才会从磁盘清楚。

cookie的作用域：Domain和Path标识了cookie的作用域：即Cookie应该发送哪些给URL。Domain标识了哪些主机可以接受cookie，如果不指定，默认为当前主机（不包含子域名）。如果指定了Domain，则一般包含子域名。

### localStorage
localStorage和cookie一样，针对在同一个域名下，会存储一段相同的localStorage。
localStorage 的容量上限为5M，并且为持久存储。且只存在于客户端，不参与服务器端的通信，避免了cookie那样带来的安全性能问题。
可以使用localStorage.setItem getItem等方法进行操作。

### sessionStorage
容量上限也为5M，但是其为会话级别存储，页面关闭之后，这部分的sessionStorage就不存在了
只存在客户端，默认不参与与服务端的通信。
当服务器第一次接收到请求时，开辟了一块session空间（创建了session对象），同时生成一个sessionID，并通过响应头的Set-Cookie：aaa=xxxxxx向客户端发送要求设置Cookie的响应。客户端收到响应后，在本机客户端设置了一个aaa=xxxxxx的cookie信息，该cookie的过期时间为浏览器会话结束。

session的缺点：只针对同时的相同客户端和服务端，若该服务器做了负载均衡，当该服务器爆满时，就会把请求换到另外的服务器进行访问，但是另外的服务器并没有存储当前服务器的session，就会导致session失效。

### IndexDB
IndexDB是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。

关于它的使用，本文侧重原理，而且 MDN 上的教程文档已经非常详尽，这里就不做赘述了，感兴趣可以看一下使用文档。

接着我们来分析一下IndexDB的一些重要特性，除了拥有数据库本身的特性，比如支持事务，存储二进制数据，还有这样一些特性需要格外注意：

- 键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
- 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
- 受同源策略限制，即无法访问跨域的数据库。


## 12. 图片懒加载
方案一:clientHeight、scrollTop 和 offsetTop
首先给图片一个占位资源:
```javascript
<img src="default.jpg" data-src="http://www.xxx.com/target.jpg" /></img>
接着，通过监听 scroll 事件来判断图片是否到达视口:

let img = document.document.getElementsByTagName("img");
let count = 0;//计数器，从第一张图片开始计

lazyload();//首次加载别忘了显示图片

window.addEventListener('scroll', lazyload);

function lazyload() {
  let viewHeight = document.documentElement.clientHeight;//视口高度
  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条卷去的高度
  for(let i = count; i <num; i++) {
    // 元素现在已经出现在视口中
    if(img[i].offsetTop < scrollHeight + viewHeight) {
      if(img[i].getAttribute("src") !== "default.jpg") continue;
      img[i].src = img[i].getAttribute("data-src");
      count ++;
    }
  }
}
```
当然，最好对 scroll 事件做节流处理，以免频繁触发:

// throttle函数我们上节已经实现
window.addEventListener('scroll', throttle(lazyload, 200));
#方案二：getBoundingClientRect
现在我们用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。

上述的 lazyload 函数改成下面这样:
```javascript
function lazyload() {
  for(let i = count; i <num; i++) {
    // 元素现在已经出现在视口中
    if(img[i].getBoundingClientRect().top < document.documentElement.clientHeight) {
      if(img[i].getAttribute("src") !== "default.jpg") continue;
      img[i].src = img[i].getAttribute("data-src");
      count ++;
    }
  }
}
```
#方案三: IntersectionObserver
这是浏览器内置的一个API，实现了监听window的scroll事件、判断是否在视口中以及节流三大功能。

我们来具体试一把：
```javascript
let img = document.document.getElementsByTagName("img");

const observer = new IntersectionObserver(changes => {
  //changes 是被观察的元素集合
  for(let i = 0, len = changes.length; i < len; i++) {
    let change = changes[i];
    // 通过这个属性判断是否在视口中
    if(change.isIntersecting) {
      const imgElement = change.target;
      imgElement.src = imgElement.getAttribute("data-src");
      observer.unobserve(imgElement);
    }
  }
})
observer.observe(img);
```
这样就很方便地实现了图片懒加载，当然这个IntersectionObserver也可以用作其他资源的预加载，功能非常强大。

## 13. 接口如何防刷
- 网关控制流量洪峰。
- 源IP请求个数限制。
- http请求头信息检验。
- 对用户唯一身份uid进行限制和校验。例如基本的长度，组合方式，甚至有效性进行判断。或者uid具有一定的时效性。
- 前后端协议采用二进制方式进行交互或者协议采用签名机制。
- 人机验证，验证码，短信验证码，滑动图片形式，12306形式

## 14. HTTPS 握手过程中，客户端如何验证证书的合法性
1. 首先什么是HTTP协议? http协议是超文本传输协议，位于tcp/ip四层模型中的应用层；通过请求/响应的方式在客户端和服务器之间进行通信；但是缺少安全性，http协议信息传输是通过明文的方式传输，不做任何加密，相当于在网络上裸奔；容易被中间人恶意篡改，这种行为叫做中间人攻击； 
2. 加密通信： 为了安全性，双方可以使用对称加密的方式key进行信息交流，但是这种方式对称加密秘钥也会被拦截，也不够安全，进而还是存在被中间人攻击风险； 于是人们又想出来另外一种方式，使用非对称加密的方式；使用公钥/私钥加解密；通信方A发起通信并携带自己的公钥，接收方B通过公钥来加密对称秘钥；然后发送给发起方A；A通过私钥解密；双发接下来通过对称秘钥来进行加密通信；但是这种方式还是会存在一种安全性；中间人虽然不知道发起方A的私钥，但是可以做到偷天换日，将拦截发起方的公钥key;并将自己生成的一对公/私钥的公钥发送给B；接收方B并不知道公钥已经被偷偷换过；按照之前的流程，B通过公钥加密自己生成的对称加密秘钥key2;发送给A； 这次通信再次被中间人拦截，尽管后面的通信，两者还是用key2通信，但是中间人已经掌握了Key2;可以进行轻松的加解密；还是存在被中间人攻击风险；
3. 解决困境：权威的证书颁发机构CA来解决； 3.1制作证书：作为服务端的A，首先把自己的公钥key1发给证书颁发机构，向证书颁发机构进行申请证书；证书颁发机构有一套自己的公私钥，CA通过自己的私钥来加密key1,并且通过服务端网址等信息生成一个证书签名，证书签名同样使用机构的私钥进行加密；制作完成后，机构将证书发给A； 3.2校验证书真伪：当B向服务端A发起请求通信的时候，A不再直接返回自己的公钥，而是返回一个证书； 说明：各大浏览器和操作系统已经维护了所有的权威证书机构的名称和公钥。B只需要知道是哪个权威机构发的证书，使用对应的机构公钥，就可以解密出证书签名；接下来，B使用同样的规则，生成自己的证书签名，如果两个签名是一致的，说明证书是有效的； 签名验证成功后，B就可以再次利用机构的公钥，解密出A的公钥key1;接下来的操作，就是和之前一样的流程了； 3.3：中间人是否会拦截发送假证书到B呢？ 因为证书的签名是由服务器端网址等信息生成的，并且通过第三方机构的私钥加密中间人无法篡改； 所以最关键的问题是证书签名的真伪；
4. https主要的思想是在http基础上增加了ssl安全层，即以上认证过程。

## 15. 一个tcp连接能发送几个http请求
1. 如果是http1.0版本协议，一般情况下不支持长连接，因此在每次请求发送完毕之后，tcp连接就会断开，因此一个tcp发送一个http请求，但是有一种情况可以将一条tcp连接保持在活跃状态，就是通过Connection和Keep-Alive首部，再请求头带上Connection:Keep-Alive,并且可以通过Keep-Alive通用首部中指定的，用逗号分隔的选项调节keep-alive的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过方法这个方法也有限制。
2. 如果是HTTP1.1版本协议，支持了长连接，因此只需要TCP连接不断开，就可以一直发送http请求，持续不断，没有上限。
3. 如果是HTTP2.0版本协议，支持多用复用，一个TCP连接是可以并发多个http请求的，同样也是支持长连接，因此只要不断开TCP的连接，HTTP请求数也是可以没有上限的持续发送。

## 16. 编码安全
### 基础安全
1. 输入验证
- 必须在可以信赖的环境完成数据校验（比如在后端）。如果在前端js进行数据校验会有被绕过篡改的风险。
- 对于不可信的输入来源（所有用户提交的参数、url头、http头）必须进行数据校验。
- 判断输入是否符合预期的数据类型、长度、数据范围、字符集合。
- 采用白名单的形式进行输入校验。
- 对于SQL注入、XSS、命令注入中常见的危险字符<>'"%|;&&/\ 应结合业务场景进行过滤。
- 相关的输入验证和过滤处理应争取从框架层面进行全局或者统一的处理，避免前后处理不一致而导致绕过。

2. 输入转义编码
- 直出页面应套用模板进行渲染，以进行HTML实体自动编码；
- 拼接输出时必须进行转义编码；比如 <转义成  &lt ;

3. 身份认证、会话管理
- 避免在url中传递会话标识。
- 控制用户登录健全的Cookie应当设置HttpOnly属性以防止被XSS漏洞/JS操纵泄露。
- 实现全站HTTPS后，Cookie应设置secure属性，使得浏览器仅在安全加密连接时才能传送使用该cookie。

4. 注册/登陆安全点
- 合理和合法的字符、长度和强度。
- 登陆失败时不应返回详细的如用户名不存在或密码错误，防止猜解用户名。
- 单个用户口令失败三次后考虑要有验证机制出现，每验过一次要立即失效防止重用。
- 后台应记录成功登陆用户名和IP时间。  
- 当登陆的IP不是经常登录的IP地址时，应进行多因素二次验证用户身份，防止用户因密码泄露被窃。

5. 传输安全/加密
- 增删改必须使用Post方法进行提交。
- 算法选择： 对称加密AES-128及以上，公钥加密使用RSA-2048及以上，哈希算法SHA-2及以上

6. 数据保护
- 不要在客户端、LocalStorage上明文保存密码或其他敏感信息。
- 涉及个人隐私的敏感信息必须加密存储并且脱敏后显示给用户。
- 用于标记资源的ID参数不能是数序数字以防被遍历，对访问资源ID的每个请求做权限校验。

7. 文件上传安全
- 上传前验证身份。
- 白名单形式校验限制上传的文件类型。不但要验证文件包头信息是否匹配，而且要验证文件后缀名，最后还要限制合适的文件大小。
- 三方存储要注意权限配置检查，以免出现泄露被任意下载等问题。

### 正则匹配
1. 日期 ： 2010-2-10, 2010-2-10 11:34:22, 2018/2/3, 2018/2/3 11:22:33
```
(^\d{4}[-/]\d{2}[-/]\d{2}$)|(^\d{4}[-/]\d{2}[-/]\d{2}\s+\d{2}\:\d{2}\:\d{2}($|\:\d{2}$))
```

2. 域名
域名都由英文字母和数字组成每一个标号不超过63个字符，也不区分大小写字母，标号中除连字符（-）外不能使用其他的标点符号，完整域名总共不超过255个字符
```
^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0, 62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0, 62})+(.)?$
```

3. 邮箱
```
^[.0-9a-zA-Z_]{1, 18}@([0-9a-zA-Z-]{1, 13}\.){1,}[a-zA-Z]{1,3}$
```

4. 中文字符
```
[\u4e00-\u9fa5]
```

### SQL注入
1. 原理：如果程序根据用户输入的参数动态生成SQL语句并执行，黑客可以通过传入恶意的参数注入自己定义的语句，使数据库执行任意自己需要的指令，实现数据窃取或入侵破坏。
2. 威胁： 拖库、敏感信息泄露，数据被篡改删除，主机服务器被入侵。