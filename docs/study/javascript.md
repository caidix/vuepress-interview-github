## JavaScript 中的垃圾回收和内存泄漏

> 由于字符串、对象和数组没有固定大小，当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

- JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

### 垃圾回收有两种方法：标记清除、引用计数。

1. 标记清除
   这是 javascript 中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。
   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
2. 引用计数
   所谓"引用计数"是指语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。如果一个值不再需要了，引用数却不为 0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。

### 哪些情况会引起内存泄漏？

> 虽然 JavaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。下面列一下内存泄漏常见的几种情况：

1. 意外的全局变量

```javascript
function foo(arg) {
  bar = "this is a hidden global variable";
  // bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。
  this.variable = "potential accidental global";
  // foo 调用自己，this 指向了全局对象（window）从而创建了全局的variable
}
foo();
```

2. 被遗忘的计时器或回调函数

```javascript
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);

```

3. 闭包
   闭包可以维持函数内局部变量，使其得不到释放。

```javascript
// 定义事件回调时，由于函数内定义函数，并且内部函数--事件回调引用外部函数，形成了闭包

function bindEvent() {
  var obj = document.createElement("xxx");
  obj.onclick = function() {
    // Even if it is a empty function
  };
}
```

4. 没有清理的 DOM 元素引用
5. 避免内存泄漏的一些方式

- 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收
- 注意程序逻辑，避免“死循环”之类
- 避免创建过多的对象

### 垃圾回收的使用场景优化

1. 数组 array 优化
   将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

```javascript
const arr = [1, 2, 3, 4];
console.log("浪里行舟");
arr.length = 0; // 可以直接让数字清空，而且数组类型不变。
// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。
```

2. 对象尽量复用
   对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为 null，尽快被垃圾回收掉。
   ```javascript
   var t = {}; // 每次循环都会创建一个新对象。
   for (var i = 0; i < 10; i++) {
     // var t = {};// 每次循环都会创建一个新对象。
     t.age = 19;
     t.name = "123";
     t.index = i;
     console.log(t);
   }
   t = null; //对象如果已经不用了，那就立即设置为 null；等待垃圾回收。
   ```
   3. 在循环中的函数表达式，能复用最好放到循环外面。
      ```javascript
      // 在循环中最好也别使用函数表达式。
      for (var k = 0; k < 10; k++) {
        var t = function(a) {
          // 创建了 10 次 函数对象。
          console.log(a);
        };
        t(k);
      }
      function t(a) {
        console.log(a);
      }
      for (var k = 0; k < 10; k++) {
        t(k);
      }
      t = null;
      ```
