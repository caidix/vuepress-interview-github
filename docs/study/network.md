# 网络

## 从输入域名到渲染出页面都经历了什么
### 浏览器的多进程架构
在chrome中，一个页面 浏览器就会为其分配一个进程，每个页面的进程相对独立，单独页面的崩溃并不会影响到其他页面的正常运行。
1. 浏览器进程:负责浏览器的用户交互、子进程管理和文件存储功能。比如tab的前进后退、处理一些不可见的底层操作如网络请求等。
2. 网络进程: 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
3. 渲染进程: 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。

### 网页加载的过程
- 首先，用户从浏览器进程里输入请求信息；
- 然后，网络进程发起 URL 请求；
- 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了；
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；
- 渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

### 用户输入
当用户在地址栏中输入查询的关键字时， 浏览器回去根据正则规则去判断它是一个网站链接还是一个搜索内容。同时会根据输入内容是否符合url协议去将输入的链接整合成一个完整的url。

### url请求过程
- 浏览器进程会通过进程间通信（IPC）把URL请求发送给网络进程，网络进程接收到请求后，会先去查找本地缓存，如果有本地缓存资源，则直接返回资源给浏览器进程。如果没有找到，那么直接
进入网络请求流程。第一步是进行DNS域名解析，将域名的所属的IP解析出来，如果是HTTPS协议，还需要建立TLS链接。
- 当通过IP地址和服务器建立了TCP连接之后，浏览器端会构建请求行、请求头等信息，并把域名相对应的cookie等数据附加在请求头中，然后向服务器发送构建的请求信息。
- 服务器接收到请求信息后，根据请求信息生成响应数据（包括响应头、响应行、响应体等信息），并发给网络进程。网络进程接受到了响应行和 响应头后，开始解析响应头的内容。
1. 重定向：在接收到服务器返回的响应头后，网络进程开始解析响应头。 如果发现返回的状态码是301或是302，说明服务器需要浏览器重定向至其他的URL，这时候网络进程会去响应头中拿到重定向的数据Location,然后重新发起HTTP或者HTTPS请求，然后重新走url的请求过程。直到响应行的状态码是200的时候，则表示浏览器可以继续处理该请求。
2. 响应数据类型处理：当处理了跳转信息之后，浏览器会根据响应头中的Content-Type来决定如何显示响应体的内容。若返回的是字节流类型的，浏览器一般会按照下载类型来处理该需求，
该请求会被提交给下载管理器，同时结束这次请求。如果是HTML，那么浏览器则会继续进行导航流程。准备渲染进程。
3. 准备渲染进程：默认情况下，chrome会为每一个页面分配一个渲染进程，当然也有例外，如果多个页面都是相同域名下的子域名，或是不同的端口，都认为他们是同一站点。Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

4. 提交文档：这里的“文档”是指 URL 请求的响应体数据。
“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

5. 渲染阶段：文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有CSS的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。
如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。
CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
在生成 Render 树的过程中，浏览器就开始调用GPU 绘制，合成图层，将内容显示在屏幕上了。
一个完整的渲染流程大致可总结为如下：

渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
创建布局树，并计算元素的布局信息。
对布局树进行分层，并生成分层树。
为每个图层生成绘制列表，并将其提交到合成线程。
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
合成线程发送绘制图块命令DrawQuad给浏览器进程。
浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

相关概念
- 构建DOM树：因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
- 构建CSSOM树： 首先，将css转换为浏览器能够理解的结构（styleSheets），并将属性里所有的值转换为渲染引擎更容易理解的、标准化的计算值（1em = 32px),从而计算出dom树中每个节点的具体样式。生成一个完整的布局树。
- 重排（更新了元素的几何属性）如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。
- 重绘（更新元素的绘制属性）如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。


## 跨域攻击
1. CSRF跨站请求伪造。通过钓鱼网站，嵌入真实网站的请求。比如用户在进入钓鱼网站之前登陆了真实的银行等站点并把COOKIE保存了起来，这时候钓鱼网站把请求发出去的时候就会把cookie也一并带上，另一端以为是正常的请求，就执行。


## 跨域
1. jsonp


2. cors跨域资源共享（Cross-origin resource sharing）在发生跨域请求之前，发送了一个OPTIONS请求去询问服务器是否允许接下来的跨域请求
OPTIONS里有几个字段： 
- Origin 发起请求原来的域
- Access-Control-Request-Method: 将要发起跨域的请求方式
- Access-Control-Request-Headers: 将要发起的跨域请求中包含的请求头字段

服务器在响应字段中来表明是否允许这个跨域请求，浏览器收到后检查如果不符合要求，就拒绝后面的请求。
- Access-Control-Allow-Origin:允许哪些域来访问（*为所有域名下的请求）
- Access-Control-Allow-Methods:允许哪些请求方式
- Access-Control-Allow-Headers: 允许那些请求头字段
- Access-Control-Allow-Credentials:是否允许携带cookie
- Access-Control-Max-Age： 服务器返回两者可通讯的有效期，在有效期内不需要再调用OPTIONS请求询问。
对此，chrome还做了优化：
如果是一个简单请求，那就直接发起请求，只需在请求中加入Origin字段表明自己来源，在响应中检查Access-Control-Allow-Origin，如果不符合要求就报错，不需要再单独询问了。
简单请求就是请求方式属于HEAD、GET、POST三者之一，请求头只有下面这些，不符合要求的就是非简单请求，就得询问了”
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：(application/x-www-form-urlencoded、multipart/form-data、text/plain)

cors简单跨域请求代码示例
```javascript
var xhr = XMLHttpRequest();
xhr.withCredentials = true;
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send('user=adsad');
xhr.onreadystatechenge=function() {
  if(xhr.readyState==4 && xhr.status ===200) {
    alert(xhr.responseText)
  }
}
```
cors跨域的优点
- 支持所有类型的http请求，功能完善
- 通过onerror事件监听进行调用错误处理
- 通过Access-Control-Allow-Origin进行资源访问授权

cors跨域缺点
- 主流（ie10）浏览器都支持cors，但ie8和ie9需要使用XDomainRequest对象进行兼容。i7以下不兼容

3. 服务器代理
顾名思义在发送跨域请求时，后端进行代理中转请求到服务器端，然后获取数据返回给前端，适用以下场景：
- 针对IE7及以下浏览器摒弃flash插件的情况，配置代理接口与前端页面同源，并中转目标服务器接口，则ajax请求不存在跨域
- 外网前端页面无法访问内网接口，配置代理接口允许前端页面访问，并中转内网接口，则外网前端页面可以跨域访问内网接口

缺点就是后端需要一定的改造工作量

## 前端跨域通信解决方案
1. document.domain + iframe
适用于主域相同，子域不同的前端通信跨域场景，比如a.cd.top和b.cd.top 两者有着相同的主域cd.top. a嵌套b，再通过js设置document.domain为主域cd.top,则两个页面满足了同源策略，从而实现了跨域通信。
```html
A页面
<iframe id="iframe" src="b.cd.top"></iframe>
<script>
  document.domain="cd.top";
  var windowB = document.getElementById('iframe').contentWindow;
  alert('B页面变量' + windowB.user)
</script>

B页面
<script>
  document.domain="cd.top"
  var user = 'CD'
</script>
``` 

优点：实现逻辑简单，不需额外的中转页面
缺点：仅适用于主域相同，子域不同的前端通信跨域场景。

2. location.hash + iframe
3. window.name+iframe