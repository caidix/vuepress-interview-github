---
title: type-challenges笔记
date: 2022-08-31 23:00:00
tags: 
  - TypeScript
author: 
  name: CD_wOw
  link: https://github.com/caidix
categories: 
  - TypeScript
permalink: /pages/8cbf2a/
---
> [TypeScript 类型体操集合题库](https://github.com/type-challenges/type-challenges)

## 简单题 Eazy

### 实现 Pick

实现 TS 内置的 Pick<T, K>，但不可以使用它。

从类型 T 中选择出属性 K，构造成一个新的类型。

```ts
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = MyPick<Todo, "title" | "completed">;

const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};

// 解
type MyPick<T, K extends keyof T> = {
  [U in K]: T[U];
};

```

### 实现 Readonly

不要使用内置的Readonly<T>，自己实现一个。

该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。

也就是不可以再对该对象的属性赋值。

```ts
interface Todo {
  title: string;
  description: string;
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar",
};

todo.title = "Hello"; // Error: cannot reassign a readonly property
todo.description = "barFoo"; // Error: cannot reassign a readonly property

// 解
type MyReadonly<T> = {
  readonly [U in keyof T]: T[U];
};

```

### 实现 Tuple to Object

不要使用内置的Readonly<T>，自己实现一个。

该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。

也就是不可以再对该对象的属性赋值。

```ts
const tuple = ["tesla", "model 3", "model X", "model Y"] as const;

type result = TupleToObject<typeof tuple>; // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}

// 解
type TupleToObject<T extends readonly any[]> = {
  [K in T[number]]: K;
};
```

### 第一个元素 First of Array

实现一个通用First<T>，它接受一个数组T并返回它的第一个元素的类型。

```ts
type arr1 = ["a", "b", "c"];
type arr2 = [3, 2, 1];

type head1 = First<arr1>; // expected to be 'a'
type head2 = First<arr2>; // expected to be 3

// 解
type First<T extends any[]> = T[0];

```

### 获取元组长度 Length of Tuple

创建一个通用的Length，接受一个readonly的数组，返回这个数组的长度。

```ts
type tesla = ["tesla", "model 3", "model X", "model Y"];
type spaceX = [
  "FALCON 9",
  "FALCON HEAVY",
  "DRAGON",
  "STARSHIP",
  "HUMAN SPACEFLIGHT"
];

type teslaLength = Length<tesla>; // expected 4
type spaceXLength = Length<spaceX>; // expected 5
// 解
type Length<T extends any[]> = T["length"];
```

### Exclude

实现内置的Exclude <T, U>类型，但不能直接使用它本身。从联合类型T中排除U的类型成员，来构造一个新的类型

> [Extends在ts中的作用](https://zhuanlan.zhihu.com/p/416883186),
> 即当条件类型作用于泛型类型时，联合类型会被拆分使用。即 MyExclude<'a' | 'b' | 'c', 'a'> 会被拆分为 'a' extends 'a'、'b' extends 'a'、'c' extends 'a'

```ts
type Result = MyExclude<"a" | "b" | "c", "a">; // 'b' | 'c'
// 解
type MyExclude<T, K> = T extends K ? never : T;

```

如果不想遍历泛型中的每一个类型，可以用方括号将泛型给括起来以表示使用该泛型的整体部分。

```ts
type MyExclude<T, U> = [T] extends [U] ? never : T

// result 此时类型为 'a' | 'b' | 'c'
type result = MyExclude<'a' | 'b' | 'c', 'a'>
```

### Awaited

假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。

例如：Promise<ExampleType>，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>;

type Result = MyAwaited<ExampleType>; // string
// 解
type MyAwaited<T> = T extends Promise<infer U> ? MyAwaited<U> : T;
```

### Awaited

假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。

例如：Promise<ExampleType>，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>;

type Result = MyAwaited<ExampleType>; // string
// 解
type MyAwaited<T> = T extends Promise<infer U> ? MyAwaited<U> : T;
```

### If

实现一个 IF 类型，它接收一个条件类型 C ，一个判断为真时的返回类型 T ，以及一个判断为假时的返回类型 F。 C 只能是 true 或者 false， T 和 F 可以是任意类型。

```ts
type A = If<true, "a", "b">; // expected to be 'a'
type B = If<false, "a", "b">; // expected to be 'b'
// 解
type If<T extends boolean, U, K> = T extends true ? U : K;

```

### Concat

在类型系统里实现 JavaScript 内置的 Array.concat 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

```ts
type Result = Concat<[1], [2]>; // expected to be [1, 2]
// 解
type Concat<T extends (keyof any)[], U extends (keyof any)[]> = [...T, ...U];
```

### Includes

在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。

```ts
type isPillarMen = Includes<["Kars", "Esidisi", "Wamuu", "Santana"], "a">; // expected to be `false`
// 解
type Includes<T extends any[], U> = T extends [infer F, ...(infer R)]
  ? F extends U
    ? true
    : Includes<R, U>
  : false;
```

### Push

在类型系统里实现通用的 Array.push 。

```ts
type Result = Push<[1, 2], "3">; // [1, 2, '3']
// 解
type Push<T extends any[], U> = [...T, U];

```

### Unshift

实现类型版本的 Array.unshift。

```ts
type Result = Unshift<[1, 2], 0>; // [0, 1, 2,]
// 解
type Unshift<T extends unknown[], U> = [U, ...T];

```

### Parameters

实现内置的 Parameters 类型，而不是直接使用它

```ts
const foo = (arg1: string, arg2: number): void => {};

type FunctionParamsType = MyParameters<typeof foo>; // [arg1: string, arg2: number]
// 解
type MyParameters<T> = T extends (...args: infer K) => unknown ? K : never;

```

## 中等题 Medium

### 获取函数返回类型 Get Return Type

不使用 ReturnType 实现 TypeScript 的 ReturnType<T> 泛型。

```ts
const fn = (v: boolean) => {
  if (v) return 1;
  else return 2;
};

type a = MyReturnType<typeof fn>; // 应推导出 "1 | 2"
// 解
type MyReturnType<T> = T extends (...args: any) => infer K ? K : never;

```

### 实现 Omit

不使用 Omit 实现 TypeScript 的 Omit<T, K> 泛型。

Omit 会创建一个省略 K 中字段的 T 对象。

```ts
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = MyOmit<Todo, "description" | "title">;

const todo: TodoPreview = {
  completed: false,
};

// 解
type ExcludeByOmit<T, K extends T> = T extends K ? never : T;

type MyOmit<T, K extends keyof T> = {
  [U in ExcludeByOmit<keyof T, K>]: T[U];
};
```

### Readonly 2

实现一个通用MyReadonly2<T, K>，它带有两种类型的参数T和K。

K指定应设置为Readonly的T的属性集。如果未提供K，则应使所有属性都变为只读，就像普通的Readonly<T>一样。

```ts
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

const todo: MyReadonly2<Todo, "title" | "description"> = {
  title: "Hey",
  description: "foobar",
  completed: false,
};

todo.title = "Hello"; // Error: cannot reassign a readonly property
todo.description = "barFoo"; // Error: cannot reassign a readonly property
todo.completed = true; // OK

// 解
type ExcludeByReadonly<T, K> = T extends K ? never : T;
type MyReadonly2<T, K extends keyof T> = {
  [U in ExcludeByReadonly<keyof T, K>]: T[U];
} & {
  readonly [V in K]: T[K];
};
```

### Deep Readonly

实现一个通用的DeepReadonly<T>，它将对象的每个参数及其子对象递归地设为只读。

您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。

```ts
type X = {
  x: {
    a: 1;
    b: "hi";
  };
  y: "hey";
  z: () => void;
};

type Expected = {
  readonly x: {
    readonly a: 1;
    readonly b: "hi";
  };
  readonly y: "hey";
};
type Todod = DeepReadonly<X>; // should be same as `Expected`

// 解
type ExcludeByReadonly<T, K> = T extends K ? never : T;
type DeepReadonly2<T> = {
  readonly [U in keyof T]: keyof T[U] extends never ? T[U] : DeepReadonly<T[U]>;
};
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends Function
    ? T[P]
    : T[P] extends Object
    ? DeepReadonly<T[P]>
    : T[P];
};
```

### 元组转合集Tuple to Union

实现泛型TupleToUnion<T>，它返回元组所有值的合集。

```ts
type Arr = ["1", "2", "3"];

type Test = TupleToUnion<Arr>; // expected to be '1' | '2' | '3'
// 解
type TupleToUnion<T extends unknown[]> = T[number];
```

### 可串联构造器Chainable Options

在 JavaScript 中我们经常会使用可串联（Chainable/Pipeline）的函数构造一个对象，但在 TypeScript 中，你能合理的给它赋上类型吗？

在这个挑战中，你可以使用任意你喜欢的方式实现这个类型 - Interface, Type 或 Class 都行。你需要提供两个函数 option(key, value) 和 get()。在 option 中你需要使用提供的 key 和 value 扩展当前的对象类型，通过 get 获取最终结果。

```ts
const result: ResultChainable = config
  .option("foo", 123)
  .option("name", "type-challenges")
  .option("bar", { value: "Hello World" })
  .get();

// 期望 result 的类型是：
interface ResultChainable {
  foo: number;
  name: string;
  bar: {
    value: string;
  };
}
//解
type Chainable<T = {}> = {
  option<K extends string, V>(
    key: K,
    value: K extends keyof T ? (V extends T[K] ? never : V) : V
  ): Chainable<Omit<T, K> & Record<K, V>>;
  get(): T;
};
type Chainable2<O = {}> = {
  option<K extends string, V>(
    key: K extends keyof O ? never : K,
    value: V
  ): Chainable<{ [key in K]: V } & O>;
  get(): O;
};
```

### 最后一个元素Last of Array

实现一个通用Last<T>，它接受一个数组T并返回其最后一个元素的类型。

```ts
type arr1 = ["a", "b", "c"];
type arr2 = [3, 2, 1];

type tail1 = Last<arr1>; // expected to be 'c'
type tail2 = Last<arr2>; // expected to be 1

// 解
type Last<T extends unknown[]> = T extends [...unknown[], infer K] ? K : never;
```

### 出堆Pop

实现一个通用Pop<T>，它接受一个数组T，并返回一个由数组T的前length-1项以相同的顺序组成的数组。
同样，您也可以实现Shift，Push和Unshift吗？

```ts
type arr1 = ["a", "b", "c", "d"];
type arr2 = [3, 2, 1];

type re1 = Pop<arr1>; // expected to be ['a', 'b', 'c']
type re2 = Pop<arr2>; // expected to be [3, 2]
type re3 = Shift<arr1>; // expected to be  ["b", "c", "d"]
type re4 = Push<arr1, "e">; // expected to be ["a", "b", "c", "d", "e"]
type re5 = Unshift<arr1, "e">; // expected to be ["e", "a", "b", "c", "d"]
// 解
type Pop<T extends unknown[]> = T extends [...infer K, unknown] ? K : never;
type Shift<T extends unknown[]> = T extends [unknown, ...infer K] ? K : never;
type Push<T extends unknown[], K> = [...T, K];
type Unshift<T extends unknown[], K> = [K, ...T];

```

### Promise.all

键入函数PromiseAll，它接受PromiseLike对象数组，返回值应为Promise<T>，其中T是解析的结果数组。

```ts
const promise1 = Promise.resolve(3);
const promise2 = 43;
const promise3 = new Promise<string>((resolve, reject) => {
  setTimeout(resolve, 100, "foo");
});

// expected to be `Promise<[number, 42, string]>`
const d = PromiseAll([promise1, promise2, promise3] as const);

// 解
declare function PromiseAll<T extends unknown[]>(
  values: readonly [...T]
): Promise<{
  [K in keyof T]: T[K] extends Promise<infer U> ? U : T[K];
}>;

```

### Type Lookup

有时，您可能希望根据某个属性在联合类型中查找类型。

在此挑战中，我们想通过在联合类型Cat | Dog中搜索公共type字段来获取相应的类型。换句话说，在以下示例中，我们期望LookUp<Dog | Cat, 'dog'>获得Dog，LookUp<Dog | Cat, 'cat'>获得Cat。

```ts
interface Cat {
  type: "cat";
  breeds: "Abyssinian" | "Shorthair" | "Curl" | "Bengal";
}

interface Dog {
  type: "dog";
  breeds: "Hound" | "Brittany" | "Bulldog" | "Boxer";
  color: "brown" | "white" | "black";
}

type MyDog = LookUp<Cat | Dog, "dog">; // expected to be `Dog`

// 解
type LookUp<T, K> = T extends { type: K } ? T : never;

```

### Trim Left

实现 TrimLeft<T> ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串开头的空白字符串。

```ts
type trime = TrimLeft<"  Hello World  ">; // 应推导出 'Hello World  '

// 解
type EmptyString = " " | "\t" | "\n";
type TrimLeft<T extends string> = T extends `${EmptyString}${infer U}`
  ? TrimLeft<U>
  : T;
```

### Trim

实现Trim<T>，它是一个字符串类型，并返回一个新字符串，其中两端的空白符都已被删除。

```ts
type trime2 = Trim<"  Hello World  ">; // expected to be 'Hello World'
// 解
type EmptyString = " " | "\t" | "\n";
type Trim<T extends string> = T extends `${EmptyString}${infer U}${EmptyString}`
  ? Trim<U>
  : T;
```

### Capitalize

实现 Capitalize<T> 它将字符串的第一个字母转换为大写，其余字母保持原样。

```ts
type capitalize = Capitalize<"hello world">; // expected to be 'Hello world'
// 解
type Capitalize<T extends string> = T extends `${infer U}${infer K}`
  ? `${Uppercase<U>}${K}`
  : T;

```

额外的，Ts的Uppercase和Loowercase

```ts
/**
 * Convert string literal type to uppercase
 */
type Uppercase<S extends string> = intrinsic;

/**
 * Convert string literal type to lowercase
 */
type Lowercase<S extends string> = intrinsic;
```

### Replace  

实现 Replace<S, From, To> 将字符串 S 中的第一个子字符串 From 替换为 To 。

```ts
type replaced = Replace<"types are fun!", "fun", "awesome">; // 期望是 'types are awesome!'
// 解
type Replace<
  S,
  From extends string,
  To extends string
> = S extends `${infer T}${From}${infer F}` ? `${T}${To}${F}` : S;
```

### ReplaceAll

实现 ReplaceAll<S, From, To> 将一个字符串 S 中的所有子字符串 From 替换为 To。

```ts
type replaced = ReplaceAll<"t y p e s", " ", "">; // 期望是 'types'
// 解
type ReplaceAll<
  T extends string,
  K extends string,
  U extends string
> = T extends `${infer F}${K}${infer E}` ? ReplaceAll<`${F}${E}`, K, U>: T;

type ReplaceAll2<
  T extends string,
  K extends string,
  U extends string
> = K extends '' ? T : T extends `${infer F}${K}${infer E}` ? `${F}${U}${ReplaceAll<E, K, U>}`: T;

```

### 追加参数Append Argument

实现一个泛型 AppendArgument<Fn, A>，对于给定的函数类型 Fn，以及一个任意类型 A，返回一个新的函数 G。G 拥有 Fn 的所有参数并在末尾追加类型为 A 的参数。

```ts
type Fn = (a: number, b: string) => number;

type Result = AppendArgument<Fn, boolean>;
// 期望是 (a: number, b: string, x: boolean) => number
// 解
type AppendArgument<T extends Function, K> = T extends (
  ...args: infer V
) => infer U
  ? (...args: [...V, K]) => U
  : never;

// 额外的，回顾Parameters，获取函数的参数
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

```

### Permutation  

实现联合类型的全排列，将联合类型转换成所有可能的全排列数组的联合类型。

```ts
type perm = Permutation<"A" | "B" | "C">; // ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']
// 解
type Permutation<T extends keyof any> = [T] extends [never]
  ? []
  : {
      [TT in T]: [TT, ...Permutation<Exclude<T, TT>>];
    }[T];

```

这相当于由

```ts
['A', ...Permutation<Exclude<T, 'A'>>] | ['B', ...Permutation<Exclude<T, 'B'>>] | ['C', ...Permutation<Exclude<T, 'C'>>]
```

到

```ts
['A', ...Permutation<'B' | 'C'>] | ['B', ...Permutation<'A' | 'C'>] | ['C', ...Permutation<'A' | 'B'>]
```

### Length of String

计算字符串的长度，类似于 String#length 。

```ts
type len = StringLength<"asdasdsa">; // 8
// 解
type StringLength<
  T extends string,
  L extends unknown[] = []
> = T extends `${infer F}${infer E}` ? StringLength<E, [...L, F]> : L["length"];
```

### Flatten

在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]>; // [1, 2, 3, 4, 5]
// 解
type Flatten<T extends unknown[]> = T extends [infer A, ...infer B]
  ? A extends unknown[]
    ? Flatten<[...A, ...B]>
    : [A, ...Flatten<[...B]>]
  : T;
```

### Append to object

实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。

```ts
type Test = { id: "1" };
type Result = AppendToObject<Test, "value", 4>; // expected to be { id: '1', value: 4 }
// 解
type AppendToObject<T extends {}, K extends string, V> = {
  [k in keyof T]: T[k];
} & {
  [v in K]: V;
};
// 解2
type AppendToObject<T, K extends keyof any, V> = {
  [key in keyof T | K]: key extends keyof T ? T[key] : V;
};
```

### Absolute

实现一个接收string,number或bigInt类型参数的Absolute类型,返回一个正数字符串。

```ts
type Test = -100;
type Result = Absolute<Test>; // expected to be "100"
// 解
type Absolute<T extends string | number | bigint> = `${T}` extends `${infer I}${infer U}` ?  I extends '-' ?  Absolute<U> : T : T;
```

### String to Union

实现一个将接收到的String参数转换为一个字母Union的类型。

```ts
type Test = '123';
type Result = StringToUnion<Test>; // expected to be "1" | "2" | "3"
// 解
type StringToUnion<T extends string, K = never> = T extends `${infer V}${infer U}`? V extends never ? K : StringToUnion<U, K | V> : K;
```

### Merge

将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。

```ts
type foo = {
  name: string;
  age: string;
};

type coo = {
  age: number;
  sex: string;
};

type Result = Merge2<foo, coo>; // expected to be {name: string, age: number, sex: string}
// 解
type Excludes<T, K> = T extends K ? never : T;
type Merge<T, K> = {
  [V in Excludes<keyof T, keyof K>]: T[V];
} &
  K;

type Merge2<T, K> = {
  [V in keyof T | keyof K]: V extends keyof K
    ? K[V]
    : V extends keyof T
    ? T[V]
    : never;
};
```

### KebabCase

FooBarBaz -> foo-bar-baz

```ts
type Result = KebabCase<"FooBarBaz">; // FooBarBaz -> foo-bar-baz
// 解
// Uncapitalize:  将字符串文字类型的第一个字符转换为小写
type KebabCase<T extends string> = T extends `${infer First}${infer Rest}`
? Rest extends Uncapitalize<Rest> 
? `${Lowercase<First>}${KebabCase<Rest>}` 
: `${Lowercase<First>}-${KebabCase<Rest>}`
: T;
// 统一Lowercase的目的是将字符串内的字符全部变成小写（因为目的就是大写的拆分成单词
```

### Diff

获取两个接口类型中的差值属性。

```ts
type Foo = {
  a: string;
  b: number;
};
type Bar = {
  a: string;
  c: boolean;
};

type Result1 = Diff<Foo, Bar>; // { b: number, c: boolean }
type Result2 = Diff<Bar, Foo>; // { b: number, c: boolean }
// Foo & Bar  {a:string b:number c:boolean}
// 解
type Diff<T, U> = {
  [key in Exclude<keyof (T & U), keyof (T | U)>]: key extends keyof T
    ? T[key]
    : key extends keyof U
    ? U[key]
    : never;
};

// 或者这样写
type Diff2<T, U> = {
  [key in Exclude<keyof (T & U), keyof (T | U)>]: (T & U)[key];
};

```

### AnyOf

在类型系统中实现类似于 Python 中 any 函数。类型接收一个数组，如果数组中任一个元素为真，则返回 true，否则返回 false。如果数组为空，返回 false。

```ts
type Sample1 = AnyOf<[1, "", false, [], {}]>; // expected to be true.
type Sample2 = AnyOf<[0, "", false, [], {}]>; // expected to be false.

type Fasly = "" | 0 | false | [] | { [p: string]: never };
type AnyOf<T extends readonly any[]> = T extends Array<Fasly> ? false : true;
```
