---
title: TypeScript枚举用法解读
date: 2022-08-31 23:00:00
tags: 
  - TypeScript
author: 
  name: CD_wOw
  link: https://github.com/caidix
categories: 
  - TypeScript
---
> [TypeScript 类型体操集合题库](https://github.com/type-challenges/type-challenges)

## Eazy

### 实现 Pick

实现 TS 内置的 Pick<T, K>，但不可以使用它。

从类型 T 中选择出属性 K，构造成一个新的类型。

```ts
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = MyPick<Todo, "title" | "completed">;

const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};

// 解
type MyPick<T, K extends keyof T> = {
  [U in K]: T[U];
};

```

### 实现 Readonly

不要使用内置的Readonly<T>，自己实现一个。

该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。

也就是不可以再对该对象的属性赋值。

```ts
interface Todo {
  title: string;
  description: string;
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar",
};

todo.title = "Hello"; // Error: cannot reassign a readonly property
todo.description = "barFoo"; // Error: cannot reassign a readonly property

// 解
type MyReadonly<T> = {
  readonly [U in keyof T]: T[U];
};

```

### 实现 Tuple to Object

不要使用内置的Readonly<T>，自己实现一个。

该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。

也就是不可以再对该对象的属性赋值。

```ts
const tuple = ["tesla", "model 3", "model X", "model Y"] as const;

type result = TupleToObject<typeof tuple>; // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}

// 解
type TupleToObject<T extends readonly any[]> = {
  [K in T[number]]: K;
};
```

### 第一个元素 First of Array

实现一个通用First<T>，它接受一个数组T并返回它的第一个元素的类型。

```ts
type arr1 = ["a", "b", "c"];
type arr2 = [3, 2, 1];

type head1 = First<arr1>; // expected to be 'a'
type head2 = First<arr2>; // expected to be 3

// 解
type First<T extends any[]> = T[0];

```

### 获取元组长度 Length of Tuple

创建一个通用的Length，接受一个readonly的数组，返回这个数组的长度。

```ts
type tesla = ["tesla", "model 3", "model X", "model Y"];
type spaceX = [
  "FALCON 9",
  "FALCON HEAVY",
  "DRAGON",
  "STARSHIP",
  "HUMAN SPACEFLIGHT"
];

type teslaLength = Length<tesla>; // expected 4
type spaceXLength = Length<spaceX>; // expected 5
// 解
type Length<T extends any[]> = T["length"];
```

### Exclude

实现内置的Exclude <T, U>类型，但不能直接使用它本身。从联合类型T中排除U的类型成员，来构造一个新的类型

> [Extends在ts中的作用](https://zhuanlan.zhihu.com/p/416883186),
> 即当条件类型作用于泛型类型时，联合类型会被拆分使用。即 MyExclude<'a' | 'b' | 'c', 'a'> 会被拆分为 'a' extends 'a'、'b' extends 'a'、'c' extends 'a'

```ts
type Result = MyExclude<"a" | "b" | "c", "a">; // 'b' | 'c'
// 解
type MyExclude<T, K> = T extends K ? never : T;

```

如果不想遍历泛型中的每一个类型，可以用方括号将泛型给括起来以表示使用该泛型的整体部分。

```ts
type MyExclude<T, U> = [T] extends [U] ? never : T

// result 此时类型为 'a' | 'b' | 'c'
type result = MyExclude<'a' | 'b' | 'c', 'a'>
```

### Awaited

假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。

例如：Promise<ExampleType>，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>;

type Result = MyAwaited<ExampleType>; // string
// 解
type MyAwaited<T> = T extends Promise<infer U> ? MyAwaited<U> : T;
```

### Awaited

假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。

例如：Promise<ExampleType>，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>;

type Result = MyAwaited<ExampleType>; // string
// 解
type MyAwaited<T> = T extends Promise<infer U> ? MyAwaited<U> : T;
```

### If

实现一个 IF 类型，它接收一个条件类型 C ，一个判断为真时的返回类型 T ，以及一个判断为假时的返回类型 F。 C 只能是 true 或者 false， T 和 F 可以是任意类型。

```ts
type A = If<true, "a", "b">; // expected to be 'a'
type B = If<false, "a", "b">; // expected to be 'b'
// 解
type If<T extends boolean, U, K> = T extends true ? U : K;

```

### Concat

在类型系统里实现 JavaScript 内置的 Array.concat 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

```ts
type Result = Concat<[1], [2]>; // expected to be [1, 2]
// 解
type Concat<T extends (keyof any)[], U extends (keyof any)[]> = [...T, ...U];
```

### Includes

在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。

```ts
type isPillarMen = Includes<["Kars", "Esidisi", "Wamuu", "Santana"], "a">; // expected to be `false`
// 解
type Includes<T extends any[], U> = T extends [infer F, ...(infer R)]
  ? F extends U
    ? true
    : Includes<R, U>
  : false;
```

### Push

在类型系统里实现通用的 Array.push 。

```ts
type Result = Push<[1, 2], "3">; // [1, 2, '3']
// 解
type Push<T extends any[], U> = [...T, U];

```

### Unshift

实现类型版本的 Array.unshift。

```ts
type Result = Unshift<[1, 2], 0>; // [0, 1, 2,]
// 解
type Unshift<T extends unknown[], U> = [U, ...T];

```

### Parameters

实现内置的 Parameters 类型，而不是直接使用它

```ts
const foo = (arg1: string, arg2: number): void => {};

type FunctionParamsType = MyParameters<typeof foo>; // [arg1: string, arg2: number]
// 解
type MyParameters<T> = T extends (...args: infer K) => unknown ? K : never;

```

## medium

### 获取函数返回类型 Get Return Type

不使用 ReturnType 实现 TypeScript 的 ReturnType<T> 泛型。

```ts
const fn = (v: boolean) => {
  if (v) return 1;
  else return 2;
};

type a = MyReturnType<typeof fn>; // 应推导出 "1 | 2"
// 解
type MyReturnType<T> = T extends (...args: any) => infer K ? K : never;

```
