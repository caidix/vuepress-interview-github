---
title: TypeScript知识
date: 2021-08-01 00:00:00
tags:
  - TypeScript
author:
  name: CD_wOw
  link: https://github.com/caidix
categories:
  - TypeScript
permalink: /pages/edc888/
---

> 在编译（转译）时期，TypeScript 编译器将通过对比检测变量接收值的类型与我们显示注解的类型，从而检测类型是否存在错误。如果两个类型完全一致，显示检测通过；如果两个类型不一致，它就会抛出一个编译期错误，告知我们编码错误

## 简单基础类型

> 基础类型在 ts 中有大小写的分别，如 String 和 string。可以自我思考一下 new String(xxx) 和 string = xxx 两者的区别从而为你的变量定义类型

1. string
2. number (ts 中还有 bigint)
3. boolean
4. symbol
5. null
6. undefined

（null 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）

## 复杂基础类型

### 数组

TypeScript 的数组和元组转译为 JavaScript 后都是数组，定义数组有两种方式:

1. 直接使用 type[]的形式定义
2. 使用 Array 泛型

```js
let numberArr: Array<number> = [1, 2, 3];
let numberArr: number[] = [1, 2, 3];
```

更加推荐使用[]的方式来定义数组，可以避免与 JSX 的语法冲突以及更少的代码量，缺点是在对应空数组时就会报错。

### 元组

元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。

```js
const require: [data:string, code: number] = [data, code]
```

## 特殊类型

### any

any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。我们可以对被注解为 any 类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且 TypeScript 还无法检测其属性是否存在、类型是否正确。我们可以把 any 类型的值赋值给任意类型（除 never 以外）的变量

```js
let anything: any = "ww";
anything = 123; //不会报错
```

### unknown

unknown 用来描述类型并不确定的变量。在 ts3.0 之前，对接收未知值的类型我们通常只能使用 any 来定义，3.0 之后我们可以将可以获取任意值的变量赋予 unknown 属性

### void、undefined、null

1. void： 函数返回空值时做的定义
2. undefined： 没什么用，表示一个可缺省、未定义的属性。
3. null：作用也不大，一般用在接口返回空对象等地方。

(我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型)

undefined 在 tsconfig strictNullChecks 为 true 的情况下是 void 和 any 类型子类型，为 false 的情况下则是除了 never 的子类型

### never

never 表示永远不会发生值的类型，是所有类型的子类型，可以给所有的类型赋值，但是除自身以外的类型不能为其赋值

```js
const neverType: never = "never";
neverType = 123; // ts(2322))
const otherStr: string = neverType; // 通过
const otherInt: number = neverType; // 通过
const props: {
  id: number,

  name?: never,
} = {
  id: 1,
};

props.name = null; // ts(2322))

props.name = "str"; // ts(2322)

props.name = 1; // ts(2322)
```

这里我们无论给 name 赋什么值，都会报类型错误，never 类型的变量也不能接受其他类型值

## 字面量类型

在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。

目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，具体示例如下：

```ts
{

  let specifiedStr: 'this is string' = 'this is string';

  let specifiedNum: 1 = 1;

  let specifiedBoolean: true = true;

}

```

字面量类型是集合类型的子类型，它是集合类型的一种更具体的表达。比如 'this is string' （这里表示一个字符串字面量类型）类型是 string 类型（确切地说是 string 类型的子类型），而 string 类型不一定是 'this is string'（这里表示一个字符串字面量类型）类型

```ts
{

  let specifiedStr: 'this is string' = 'this is string';

  let str: string = 'any string';

  specifiedStr = str; // ts(2322) 类型 '"string"' 不能赋值给类型 'this is string'

  str = specifiedStr; // ok 

}

```

比如说我们用“马”比喻 string 类型，即“黑马”代指 'this is string' 类型，“黑马”肯定是“马”，但“马”不一定是“黑马”，它可能还是“白马”“灰马”。因此，'this is string' 字面量类型可以给 string 类型赋值，但是 string 类型不能给 'this is string' 字面量类型赋值，这个比喻同样适合于形容数字、布尔等其他字面量和它们父类的关系。

## 返回值类型

在 JavaScript 中，我们知道一个函数可以没有显式 return，此时函数的返回值应该是 undefined, 如果我们显式声明函数的返回值类型为 undfined，将会得到如下所示的错误提醒。

```ts
function fn() {

  // TODO

}

console.log(fn()); // => undefined

function fn(): undefined { // ts(2355) A function whose declared type is neither 'void' nor 'any' must return a value
  // TODO
}

```

当没有返回值时函数正确的赋值方式应该是void。由于函数返回值的类型可以在 TypeScript 中被推断出来，即可缺省，通常我们可以不用专门定义，但是有些特例需要我们显式声明返回值类型，比如 Generator 函数的返回值。

ES6 中新增的 Generator 函数在 TypeScript 中也有对应的类型定义。

Generator 函数返回的是一个 Iterator 迭代器对象，我们可以使用 Generator 的同名接口泛型或者 Iterator 的同名接口泛型表示返回值的类型（Generator 类型继承了 Iterator 类型），示例如下：

```ts
type AnyType = boolean;

type AnyReturnType = string;

type AnyNextType = number;

function *gen(): Generator<AnyType, AnyReturnType, AnyNextType> {

  const nextValue = yield true; // nextValue 类型是 number，yield 后必须是 boolean 类型

  return `${nextValue}`; // 必须返回 string 类型

}
```

## 类型拓宽

比如对 null 和 undefined 的类型进行拓宽，通过 let、var 定义的变量如果满足未显式声明类型注解且被赋予了 null 或 undefined 值，则推断出这些变量的类型是 any：

```ts
{

  let x = null; // let定义的变量类型拓宽成 any

  let y = undefined; // let定义的变量类型拓宽成 any

  /** -----分界线------- */

  const z = null; // 类型是 null

  /** -----分界线------- */

  let anyFun = (param = null) => param; // 形参类型是 null

  let z2 = z; // 类型是 null

  let x2 = x; // 类型是 null

  let y2 = y; // 类型是 undefined

//TIPS: 在严格模式下，一些比较老的版本中（2.0）null 和 undefined 并不会被拓宽成“any”
}

```

## 类型缩小

在 TypeScript 中，我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合.例如我们采用if判断将原本处于number|string类型的变量缩小为其中一个子类型，当然不止限于if，还有三目运算符、switch等等约束条件都能产生同样的效果

## 类型断言

类型断言是对类型的强制转化，让 ts 接受它的类型选择
例如：

```js
const nums: number[] = [1, 2, 3, 4, 5];
const bigNumber: number = nums.find((i) => i > 2); // 由于 find方法会返回number | undefined 类型，此时定义的bigNumber只能是number类型，这个时候就会出现类型错误

// 通过as (type) 的方式让ts默认认为返回的就是一个number类型的参数
const bigNumber: number = nums.find((i) => i > 2) as number;
// 尖括号也行，但是会和jsx语法产生冲突
const bigNumber: number = \<number>nums.find((i) => i > 2);
```

## 函数重载

JavaScript 是一门动态语言，针对同一个函数，它可以有多种不同类型的参数与返回值，这就是函数的多态。

而在 TypeScript 中，也可以相应地表达不同类型的参数和返回值的函数

```ts
function convert(x: string | number | null): string | number | -1 {

    if (typeof x === 'string') {

        return Number(x);

    }

    if (typeof x === 'number') {

        return String(x);

    }

    return -1;

}

const x1 = convert('1'); // => string | number

const x2 = convert(1); // => string | number

const x3 = convert(null); // => string | number
```

我们把 convert 函数的 string 类型的值转换为 number 类型，number 类型转换为 string 类型，而将 null 类型转换为数字 -1。此时， x1、x2、x3 的返回值类型都会被推断成 string | number 。

那么，有没有一种办法可以更精确地描述参数与返回值类型约束关系的函数类型呢？有，这就是函数重载（Function Overload），如下示例中 1~3 行定义了三种各不相同的函数类型列表，并描述了不同的参数类型对应不同的返回值类型，而从第 4 行开始才是函数的实现。

```ts
function convert(x: string): number;
function convert(x: number): string;
function convert(x: null): -1;
function convert(x: string | number | null): any {
    if (typeof x === 'string') {
        return Number(x);
    }
    if (typeof x === 'number') {
        return String(x);
    }
    return -1;
}
const x1 = convert('1'); // => number

const x2 = convert(1); // => string

const x3 = convert(null); // -1
```

> 函数重载列表的各个成员（即示例中的 1 ~ 3 行）必须是函数实现（即示例中的第 4 行）的子集，例如 “function convert(x: string): number”是“function convert(x: string | number | null): any”的子集。

在 convert 函数被调用时，TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义。因此，我们需要把最精确的函数重载放到前面。例如我们在第 14 行传入了字符串 '1'，查找到第 1 行即匹配，而第 15 行传入了数字 1，则查找到第 2 行匹配。

我们通过以下一个示例进行具体说明

```ts
interface P1 {
  name: string;
}

interface P2 extends P1 {
  age: number;
}

function convert(x: P1): number;
function convert(x: P2): string;
function convert(x: P1 | P2): any {}
const x1 = convert({ name: "" } as P1); // => number
const x2 = convert({ name: "", age: 18 } as P2); // number
```

## 类型谓词（is）

```js

function isString(s): s is string { // 类型谓词
  return typeof s === 'string';
}

function isNumber(n: number) {
  return typeof n === 'number';
}

function operator(x: unknown) {
  if(isString(x)) { // ok x 类型缩小为 string
  }
  if (isNumber(x)) { // ts(2345) unknown 不能赋值给 number
  }
}
```

在上述代码中，在添加返回值类型的地方，我们通过“参数名 + is + 类型”的格式明确表明了参数的类型，进而引起类型缩小，所以类型谓词函数的一个重要的应用场景是实现自定义类型守卫（详见第 11 讲）。

## Ts 工具类型

1. enum: 枚举

2. type, interface

3. 联合类型 | (联合类型一次只能一种类型；而交叉类型每次都是多个类型的合并类型。)

4. 交叉类型 & (联合类型一次只能一种类型；而交叉类型每次都是多个类型的合并类型。)

5. typeof

typeof 操作符可以用来获取一个变量声明或对象的类型。

```ts
function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray; // -> (x: number) => number[]
```

6. keyof

keyof 操作符可以用来一个对象中的所有 key 值：

```ts
interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"
```

7. in

in 用来遍历枚举类型：

```ts
type Keys = "a" | "b" | "c";

type Obj = {
  [p in Keys]: any;
}; // -> { a: any, b: any, c: any }
```

8. extends

有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。

```ts
interface ILengthwise {
  length: number;
}

function loggingIdentity<T extends ILengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

loggingIdentity(3);
loggingIdentity({ length: 10, value: 3 });
```

9. Paritial

Partial\<T> 的作用就是将某个类型里的属性全部变为可选项 ?。

```js
type Partial<T> = {
  [P in keyof T]?: T[P];
};

interface Person {
  name: string;
  age?: number;
  weight?: number;
}

type PartialPerson = Partial<Person>;

// 相当于
interface PartialPerson {
  name?: string;
  age?: number;
  weight?: number;
}

```

10. Reuqired

Required\<T> 的作用就是将某个类型里的属性全部变为必选项。

```js
type Required<T> = {
  [P in keyof T]-?: T[P];
};

type RequiredPerson = Required<Person>;

// 相当于

interface RequiredPerson {
  name: string;
  age: number;
  weight: number;
}
```

映射类型在键值的后面使用了一个 - 符号，- 与 ? 组合起来表示去除类型的可选属性，因此给定类型的所有属性都变为了必填。

11. Readonly

Readonly\<T> 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。

```js
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type ReadonlyPerson = Readonly<Person>;

// 相当于

interface ReadonlyPerson {
  readonly name: string;
  readonly age?: number;
  readonly weight?: number;
}

```

12. Record

Record\<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。

```ts
interface PageInfo {
  title: string;
}

type Page = "home" | "about" | "contact";

const x: Record<Page, PageInfo> = {
  about: { title: "about" },
  contact: { title: "contact" },
  home: { title: "home" },
};
```

13. Exclude

Exclude\<T, U> 的作用是将某个类型中属于另一个的类型移除掉。

```ts
type Exclude<T, U> = T extends U ? never : T;

type T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"
```

14. Extract

Extract\<T, U> 的作用是从 T 中提取出 U。从联合类型中提取指定的类型。

```ts
type T0 = Extract<"a" | "b" | "c", "a" | "f">; // "a"
type T1 = Extract<string | number | (() => void), Function>; // () => void
```

15. Pick

Pick 工具类型可以从给定的类型中选取出指定的键值，然后组成一个新的类型

```ts
interface Person {
  name: string;
  age?: number;
  weight?: number;
}

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type NewPerson = Pick<Person, "name" | "age">;
// 相当于
interface NewPerson {
  name: string;
  age?: number;
}
```

16. Omit

与 Pick 类型相反，Omit 工具类型的功能是返回去除指定的键值之后返回的新类型

```ts
interface Person {
  name: string;
  age?: number;
  weight?: number;
}

type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

type NewPerson = Omit<Person, "weight">;

// 相当于
interface NewPerson {
  name: string;
  age?: number;
}
```

17. NonNullable

从联合类型中去除 null 或者 undefined 的类型。

```ts
type NonNullable<T> = T extends null | undefined ? never : T;

// 等同于使用 Exclude

type NonNullable<T> = Exclude<T, null | undefined>;

type T = NonNullable<string | number | undefined | null>; // => string | number
```

18. Equal

判断两个类型是否相等， 当前社区上主要有两种方案。
[参考issue](https://github.com/Microsoft/TypeScript/issues/27024#issuecomment-420227672)
第一种：

```ts
export type Equal1<T, S> =
  [T] extends [S] ? (
    [S] extends [T] ? true : false
  ) : false
```

目前该方案的唯一缺点是会将 any 类型与其它任何类型判为相等。

```ts
type T = Equal1<{x:any}, {x:number}> // T: true
```

第二种：

```ts
export type Equal2<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<U>() => U extends Y ? 1 : 2) ? true : false
```

目前该方案的唯一缺点是在对交叉类型的处理上有一点瑕疵。

```ts
type T = Equal2<{x:1} & {y:2}, {x:1, y:2}> // false
```

### 函数类型

1. ConstructorParameters

ConstructorParameters 可以用来获取构造函数的构造参数，而 ConstructorParameters 类型的实现则需要使用 infer 关键字推断构造参数的类型。

关于 infer 关键字，我们可以把它当成简单的模式匹配来看待。如果真实的参数类型和 infer 匹配的一致，那么就返回匹配到的这个类型。

```ts
type ConstructorParameters<
  T extends new (...args: any) => any
> = T extends new (...args: infer P) => any ? P : never;

class Person {
  constructor(name: string, age?: number) {}
}

type T = ConstructorParameters<typeof Person>; // [name: string, age?: number]
// ConstructorParameters 泛型接收了一个参数，并且限制了这个参数需要实现构造函数。于是，我们通过 infer 关键字匹配了构造函数内的构造参数，并返回了这些参数。
```

2. ThisType

ThisType 的作用是可以在对象字面量中指定 this 的类型。ThisType 不返回转换后的类型，而是通过 ThisType 的泛型参数指定 this 的类型（如果想使用这个工具类型，那么需要开启 noImplicitThis 的 TypeScript 配置）

```ts
type ObjectDescriptor<D, M> = {
  data?: D;
  methods?: M & ThisType<D & M>; // methods 中 this 的类型是 D & M
};
```

### 字符串类型

```ts
// 转换字符串字面量到大写字母

type Uppercase<S extends string> = intrinsic;

// 转换字符串字面量到小写字母

type Lowercase<S extends string> = intrinsic;

// 转换字符串字面量的第一个字母为大写字母

type Capitalize<S extends string> = intrinsic;

// 转换字符串字面量的第一个字母为小写字母

type Uncapitalize<S extends string> = intrinsic;

type T0 = Uppercase<"Hello">; // => 'HELLO'

type T1 = Lowercase<T0>; // => 'hello'

type T2 = Capitalize<T1>; // => 'Hello'

type T3 = Uncapitalize<T2>; // => 'hello'
```
