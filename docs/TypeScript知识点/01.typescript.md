---
title: TypeScript知识
date: 2021-08-01 00:00:00
tags:
  - TypeScript
author:
  name: CD_wOw
  link: https://github.com/caidix
categories:
  - TypeScript
permalink: /pages/edc888/
---

> 在编译（转译）时期，TypeScript 编译器将通过对比检测变量接收值的类型与我们显示注解的类型，从而检测类型是否存在错误。如果两个类型完全一致，显示检测通过；如果两个类型不一致，它就会抛出一个编译期错误，告知我们编码错误

## 简单基础类型

> 基础类型在 ts 中有大小写的分别，如 String 和 string。可以自我思考一下 new String(xxx) 和 string = xxx 两者的区别从而为你的变量定义类型

1. string
2. number (ts 中还有 bigint)
3. boolean
4. symbol
5. null
6. undefined

（null 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）

## 复杂基础类型

### 数组

TypeScript 的数组和元组转译为 JavaScript 后都是数组，定义数组有两种方式:

1. 直接使用 type[]的形式定义
2. 使用 Array 泛型

```js
let numberArr: Array<number> = [1, 2, 3];
let numberArr: number[] = [1, 2, 3];
```

更加推荐使用[]的方式来定义数组，可以避免与 JSX 的语法冲突以及更少的代码量，缺点是在对应空数组时就会报错。

### 元组

元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。

```js
const require: [data:string, code: number] = [data, code]
```

## 特殊类型

### any

any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。我们可以对被注解为 any 类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且 TypeScript 还无法检测其属性是否存在、类型是否正确。我们可以把 any 类型的值赋值给任意类型（除 never 以外）的变量

```js
let anything: any = "ww";
anything = 123; //不会报错
```

### unknown

unknown 用来描述类型并不确定的变量。在 ts3.0 之前，对接收未知值的类型我们通常只能使用 any 来定义，3.0 之后我们可以将可以获取任意值的变量赋予 unknown 属性

### void、undefined、null

1. void： 函数返回空值时做的定义
2. undefined： 没什么用，表示一个可缺省、未定义的属性。
3. null：作用也不大，一般用在接口返回空对象等地方。

(我们可以把 undefined 值或类型是 undefined 的变量赋值给 void 类型变量，反过来，类型是 void 但值是 undefined 的变量不能赋值给 undefined 类型)

### never

never 表示永远不会发生值的类型，是所有类型的子类型，可以给所有的类型赋值，但是除自身以外的类型不能为其赋值

```js
const neverType: never = "never";
neverType = 123; // ts(2322))
const otherStr: string = neverType; // 通过
const otherInt: number = neverType; // 通过
const props: {
  id: number,

  name?: never,
} = {
  id: 1,
};

props.name = null; // ts(2322))

props.name = "str"; // ts(2322)

props.name = 1; // ts(2322)
```

这里我们无论给 name 赋什么值，都会报类型错误，never 类型的变量也不能接受其他类型值

## 类型断言

类型断言是对类型的强制转化，让 ts 接受它的类型选择
例如：

```js
const nums: number[] = [1, 2, 3, 4, 5];
const bigNumber: number = nums.find((i) => i > 2); // 由于 find方法会返回number | undefined 类型，此时定义的bigNumber只能是number类型，这个时候就会出现类型错误

// 通过as (type) 的方式让ts默认认为返回的就是一个number类型的参数
const bigNumber: number = nums.find((i) => i > 2) as number;
// 尖括号也行，但是会和jsx语法产生冲突
const bigNumber: number = \<number>nums.find((i) => i > 2);
```

## 函数重载

## 类型谓词（is）

```js

function isString(s): s is string { // 类型谓词
  return typeof s === 'string';
}

function isNumber(n: number) {
  return typeof n === 'number';
}

function operator(x: unknown) {
  if(isString(x)) { // ok x 类型缩小为 string
  }
  if (isNumber(x)) { // ts(2345) unknown 不能赋值给 number
  }
}
```

在上述代码中，在添加返回值类型的地方，我们通过“参数名 + is + 类型”的格式明确表明了参数的类型，进而引起类型缩小，所以类型谓词函数的一个重要的应用场景是实现自定义类型守卫（详见第 11 讲）。

## Ts 工具类型

1. enum: 枚举

2. type, interface

3. 联合类型 | (联合类型一次只能一种类型；而交叉类型每次都是多个类型的合并类型。)

4. 交叉类型 & (联合类型一次只能一种类型；而交叉类型每次都是多个类型的合并类型。)

5. typeof

typeof 操作符可以用来获取一个变量声明或对象的类型。

```ts
function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray; // -> (x: number) => number[]
```

6. keyof

keyof 操作符可以用来一个对象中的所有 key 值：

```ts
interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"
```

7. in

in 用来遍历枚举类型：

```ts
type Keys = "a" | "b" | "c";

type Obj = {
  [p in Keys]: any;
}; // -> { a: any, b: any, c: any }
```

8. extends

有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。

```ts
interface ILengthwise {
  length: number;
}

function loggingIdentity<T extends ILengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

loggingIdentity(3);
loggingIdentity({ length: 10, value: 3 });
```

9.  Paritial

Partial\<T> 的作用就是将某个类型里的属性全部变为可选项 ?。

10. Reuqired

Required\<T> 的作用就是将某个类型里的属性全部变为必选项。

11. Readonly

Readonly\<T> 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。

12. Record

Record\<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。

```ts
interface PageInfo {
  title: string;
}

type Page = "home" | "about" | "contact";

const x: Record<Page, PageInfo> = {
  about: { title: "about" },
  contact: { title: "contact" },
  home: { title: "home" },
};
```

13. Exclude

Exclude\<T, U> 的作用是将某个类型中属于另一个的类型移除掉。

```ts
type T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"
```

14. Extract

Extract\<T, U> 的作用是从 T 中提取出 U。从联合类型中提取指定的类型。

```ts
type T0 = Extract<"a" | "b" | "c", "a" | "f">; // "a"
type T1 = Extract<string | number | (() => void), Function>; // () => void
```

15. Pick

Pick 工具类型可以从给定的类型中选取出指定的键值，然后组成一个新的类型

```ts
interface Person {
  name: string;
  age?: number;
  weight?: number;
}

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type NewPerson = Pick<Person, "name" | "age">;
// 相当于
interface NewPerson {
  name: string;
  age?: number;
}
```

16. Omit

与 Pick 类型相反，Omit 工具类型的功能是返回去除指定的键值之后返回的新类型

```ts
interface Person {
  name: string;
  age?: number;
  weight?: number;
}

type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

type NewPerson = Omit<Person, "weight">;

// 相当于
interface NewPerson {
  name: string;
  age?: number;
}
```

17. NonNullable

从联合类型中去除 null 或者 undefined 的类型。

```ts
type NonNullable<T> = T extends null | undefined ? never : T;

// 等同于使用 Exclude

type NonNullable<T> = Exclude<T, null | undefined>;

type T = NonNullable<string | number | undefined | null>; // => string | number
```

### 函数类型

1. ConstructorParameters

ConstructorParameters 可以用来获取构造函数的构造参数，而 ConstructorParameters 类型的实现则需要使用 infer 关键字推断构造参数的类型。

关于 infer 关键字，我们可以把它当成简单的模式匹配来看待。如果真实的参数类型和 infer 匹配的一致，那么就返回匹配到的这个类型。

```ts
type ConstructorParameters<
  T extends new (...args: any) => any
> = T extends new (...args: infer P) => any ? P : never;

class Person {
  constructor(name: string, age?: number) {}
}

type T = ConstructorParameters<typeof Person>; // [name: string, age?: number]
// ConstructorParameters 泛型接收了一个参数，并且限制了这个参数需要实现构造函数。于是，我们通过 infer 关键字匹配了构造函数内的构造参数，并返回了这些参数。
```

2. ThisType

ThisType 的作用是可以在对象字面量中指定 this 的类型。ThisType 不返回转换后的类型，而是通过 ThisType 的泛型参数指定 this 的类型（如果想使用这个工具类型，那么需要开启 noImplicitThis 的 TypeScript 配置）

```ts
type ObjectDescriptor<D, M> = {
  data?: D;
  methods?: M & ThisType<D & M>; // methods 中 this 的类型是 D & M
};
```

### 字符串类型

```ts
// 转换字符串字面量到大写字母

type Uppercase<S extends string> = intrinsic;

// 转换字符串字面量到小写字母

type Lowercase<S extends string> = intrinsic;

// 转换字符串字面量的第一个字母为大写字母

type Capitalize<S extends string> = intrinsic;

// 转换字符串字面量的第一个字母为小写字母

type Uncapitalize<S extends string> = intrinsic;

type T0 = Uppercase<"Hello">; // => 'HELLO'

type T1 = Lowercase<T0>; // => 'hello'

type T2 = Capitalize<T1>; // => 'Hello'

type T3 = Uncapitalize<T2>; // => 'hello'
```
